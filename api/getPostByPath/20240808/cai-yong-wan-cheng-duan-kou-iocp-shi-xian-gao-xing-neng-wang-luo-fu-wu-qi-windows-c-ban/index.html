{"type":"getPostByPath","data":{"title":"采用完成端口（IOCP）实现高性能网络服务器（Windows c++版）","date":"2024-08-08T07:02:19.000Z","description":"","categories":[{"name":"iocp","_id":"clzpq9hti0024sger18ilbifo"},{"name":"c++","_id":"clzpqtvw00001wsercg35c43s"}],"tags":[{"name":"iocp","_id":"clzpq9hub003dsgerfbp56xjj"},{"name":"c++","_id":"clzpq9hyy00ahsgeragj8504x"}],"content":"<p>转载自 <a href=\"https://www.cnblogs.com/yuanchenhui/p/iocp_windows.html\">采用完成端口（IOCP）实现高性能网络服务器（Windows c++版）</a></p>\n<h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\">※</a>前言</h2>\n<p>TCP\\IP已成为业界通讯标准。现在越来越多的程序需要联网。网络系统分为服务端和客户端，也就是c\\s模式(client \\ server)。client一般有一个或少数几个连接；server则需要处理大量连接。大部分情况下，只有服务端才特别考虑性能问题。本文主要介绍服务端处理方法，当然也可以用于客户端。</p>\n<p>我也发表过c#版网络库。其实，我最早是从事c++ 开发，多年前就实现了对完成端口的封装。最近又把以前的代码整理一下，做了测试，也和c#版网络库做了粗略对比。总体上，还是c++ 性能要好一些。c#网络库见文章<a href=\"https://www.cnblogs.com/yuanchenhui/p/asyn_scoket.html\">《一个高性能异步socket封装库的实现思路》</a>。</p>\n<p>Windows平台下处理socket通讯有多种方式；大体可以分为阻塞模式和非阻塞模式。阻塞模式下send和recv都是阻塞的。简单讲一下这两种模式处理思路。</p>\n<p>阻塞模式：比如调用send时，把要发送的数据放到网络发送缓冲区才返回。如果这时，网络发送缓冲区满了，则需要等待更久的时间。socket的收发其实也是一种IO，和读写硬盘数据有些类似。一般来讲，IO处理速度总是慢的，不要和内存处理并列。对于调用recv，至少读取一个字节数据，函数才会返回。所以对于recv，一般用一个单独的线程处理。</p>\n<p>非阻塞模式：send和recv都是非阻塞的；比如调用send，函数会立马返回。真正的发送结果，需要等待操作系统的再次通知。阻塞模式下一步可以完成的处理，在非阻塞模式下需要两步。就是多出的这一步，导致开发难度大大增加。高性能大并发网络服务器必须采用非阻塞模式。完成端口（IOCP）是非阻塞模式中性能最好的一种。</p>\n<p>作者多年以前，就开始从事winsocket开发，最开始是采用c++、后来采用c#。对高性能服务器设计的体会逐步加深。人要在一定的压力下才能有所成就。最开始的一个项目是移动信令分析，所处理的消息量非常大；高峰期，每秒要处理30万条信令，占用带宽500M。无论是socket通讯还是后面的数据处理，都必须非常优化。所以从项目的开始，我就谨小慎微，对性能特别在意。项目实施后，程序的处理性能出乎意料。一台服务器可以轻松处理一个省的信令数据（项目是08年开始部署，现在的硬件性能远超当时）。程序界面如下：</p>\n<p><img src=\"245753-20181006115839129-412875875.jpg\" alt=\"\"></p>\n<p><em>题外话</em> 通过这个项目我也有些体会：1）不要怀疑Windows的性能，不要怀疑微软的实力。有些人遇到性能问题，或是遇到奇怪的bug，总是把责任推给操作系统；这是不负责任的表现。应该反思自己的开发水平、设计思路。2）开发过程中，需要把业务吃透；业务是开发的基石。不了解业务，不可能开发出高性能的程序。所有的处理都有取舍，每个函数都有他的适应场合。有时候需要拿来主义，有时候需要从头开发一个函数。</p>\n<h2 id=\"目标\"><a class=\"header-anchor\" href=\"#目标\">※</a>目标</h2>\n<p>开发出一个完善的IOCP程序是非常困难的。怎么才能化繁为简？需要把IOCP封装；同时这个封装库要有很好的适应性，能满足各种应用场景。一个好的思路就能事半功倍。我就是围绕这两个目标展开设计。</p>\n<p>1. 程序开发接口</p>\n<p>socket处理本质上可以分为：读、写、accept、socket关闭等事件。把这些事件分为两类：a）读、accept、socket关闭 b）写；a类是从库中获取消息，b类是程序主动调用函数。对于a类消息可以调用如下函数：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//消息事件</span></span><br><span class=\"line\"><span class=\"built_in\">enum</span> Enum_MessageType :<span class=\"built_in\">char</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EN_Accept = <span class=\"number\">0</span>,</span><br><span class=\"line\">    EN_Read,</span><br><span class=\"line\">    EN_Close,</span><br><span class=\"line\">    EN_Connect</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">SocketMessage</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    SOCKET         Socket;</span><br><span class=\"line\">    Enum_MessageType MessageType;</span><br><span class=\"line\">    <span class=\"comment\">//当MessageType为EN_Connect时，BufferLen为EasyIocpLib_Connect函数的tag参数</span></span><br><span class=\"line\">    INT32 BufferLen;</span><br><span class=\"line\">    <span class=\"built_in\">char</span> *Buffer;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不停的调用此函数，返回数据</span></span><br><span class=\"line\">SocketMessage* EasyIocpLib_GetMessage(UINT64 handle);</span><br></pre></td></tr></table></figure>\n<p>对于b类，就是发送数据。当调用发送时，数据被放到库的发送缓冲中，函数里面返回。接口如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> EN_SEND_BUFFER_RESULT</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    en_send_buffer_ok = <span class=\"number\">0</span>, <span class=\"comment\">//放入到发送缓冲</span></span><br><span class=\"line\">    en_not_validate_socket, <span class=\"comment\">//无效的socket句柄</span></span><br><span class=\"line\">    en_send_buffer_full     <span class=\"comment\">//发送缓冲区满</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">EN_SEND_BUFFER_RESULT <span class=\"title\">EasyIocpLib_SendMessage</span>(<span class=\"params\">UINT64 handle, SOCKET socket,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        <span class=\"built_in\">char</span>* buffer, <span class=\"built_in\">int</span> offset, <span class=\"built_in\">int</span> len, BOOL mustSend = FALSE</span>)</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>总的思路是接收时，放到接收缓冲；发送时，放到发送缓冲。外部接口只对内存中数据操作，没有任何阻塞。</p>\n<pre><code>  2. 具有广泛的适应性\n</code></pre>\n<p>如果网络库可以用到各种场景，所处理的逻辑必须与业务无关。所以本库接收和发送的都是字节流。包协议一般有长度指示或有开始结束符。需要把字节流分成一个个完整的数据包。这就与业务逻辑有关了。所以要有分层处理思想：</p>\n<p><img src=\"245753-20181006125501755-1321968611.png\" alt=\"\"></p>\n<h2 id=\"库性能测试\"><a class=\"header-anchor\" href=\"#库性能测试\">※</a>库性能测试</h2>\n<p>首先对库的性能做测试，使大家对库的性能有初步印象。这些测试都不是很严格，大体能反映程序的性能。IOCP是可扩展的，就是同时处理10个连接与同时处理1000个连接，性能上没有差别。</p>\n<p>我的机器配置不高，cup为酷睿2 双核 E7500，相当于i3低端。</p>\n<p>1）两台机器测试，一个发送，一个接收：带宽占用40M，整体cpu占用10%，程序占用cpu不超过3%。</p>\n<p><img src=\"245753-20181006130210068-1117909271.jpg\" alt=\"\"></p>\n<p>2）单台机器，两个程序互发：收发数据达到30M字节，相当于300M带宽，cpu占用大概25%。</p>\n<p><img src=\"245753-20181006130957278-1963735577.jpg\" alt=\"\"></p>\n<p>3）采用更高性能机器测试，两个程序对发数据：cpu为：i5-7500 CPU @ 3.40GHz</p>\n<p><img src=\"245753-20181009084505283-1428781234.jpg\" alt=\"\"></p>\n<p>收发数据总和80M字节每秒，接近1G带宽。cpu占用25%。</p>\n<p>测试程序下载地址 ：<a href=\"https://download.csdn.net/download/qq_29939347/10707675\">《完成端口（IOCP）性能测试程序（c++版本 64位程序）》</a>。只有exe程序，不包括代码。</p>\n<h2 id=\"网络库设计思路\"><a class=\"header-anchor\" href=\"#网络库设计思路\">※</a>网络库设计思路</h2>\n<p>服务器要启动监听，当有客户端连接时，生成新的socket句柄；该socket句柄与完成端口关联，后续读写都通过完成端口完成。</p>\n<ol>\n<li>socket监听（Accept处理）</li>\n</ol>\n<p>关于监听处理，参考我另一篇文章<a href=\"https://www.cnblogs.com/yuanchenhui/p/icop_accept.html\">《单线程实现同时监听多个端口》</a>。</p>\n<ol start=\"2\">\n<li>数据接收</li>\n</ol>\n<p>收发数据要用到类型OVERLAPPED。需要对该类型进一步扩充，这样当从完成端口返回时，可以获取具体的数据和操作类型。这是处理完成端口一个非常重要的技巧。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//完成端口操作类型</span></span><br><span class=\"line\">typedef <span class=\"built_in\">enum</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    POST_READ_PKG, <span class=\"comment\">//读</span></span><br><span class=\"line\">    POST_SEND_PKG, <span class=\"comment\">//写</span></span><br><span class=\"line\">    POST_CONNECT_PKG,</span><br><span class=\"line\">    POST_CONNECT_RESULT</span><br><span class=\"line\">&#125;OPERATION_TYPE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> PER_IO_OPERATION_DATA</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    WSAOVERLAPPED overlap; <span class=\"comment\">//第一个变量，必须是操作系统定义的结构</span></span><br><span class=\"line\">    OPERATION_TYPE opType;</span><br><span class=\"line\">    SOCKET         socket;</span><br><span class=\"line\">    WSABUF         buf;    <span class=\"comment\">//要读取或发送的数据</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>发送处理：overlap包含要发送的数据。调用此函数会立马返回；当有数据到达时，会有通知。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL NetServer::PostRcvBuffer(SOCKET socket, PER_IO_OPERATION_DATA *overlap)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD flags = MSG_PARTIAL;</span><br><span class=\"line\">    DWORD numToRecvd = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    overlap-&gt;opType = OPERATION_TYPE::POST_READ_PKG;</span><br><span class=\"line\">    overlap-&gt;socket = socket;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> ret = WSARecv(socket,</span><br><span class=\"line\">        &amp;overlap-&gt;buf,</span><br><span class=\"line\">        <span class=\"number\">1</span>,</span><br><span class=\"line\">        &amp;numToRecvd,</span><br><span class=\"line\">        &amp;flags,</span><br><span class=\"line\">        &amp;(overlap-&gt;overlap),</span><br><span class=\"line\">        NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (WSAGetLastError() == WSA_IO_PENDING)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret = NO_ERROR;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret = SOCKET_ERROR;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ret == NO_ERROR);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从完成端口获取读数据事件通知：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DWORD NetServer::Deal_CompletionRoutine()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DWORD dwBytesTransferred;</span><br><span class=\"line\">    PER_IO_OPERATION_DATA *lpPerIOData = NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    ULONG_PTR    Key;</span><br><span class=\"line\">    BOOL rc;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> error;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m_bServerStart)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        error = NO_ERROR;</span><br><span class=\"line\">        <span class=\"comment\">//从完成端口获取事件</span></span><br><span class=\"line\">        rc = GetQueuedCompletionStatus(</span><br><span class=\"line\">            m_hIocp,</span><br><span class=\"line\">            &amp;dwBytesTransferred,</span><br><span class=\"line\">            &amp;Key,</span><br><span class=\"line\">            (LPOVERLAPPED *)&amp;lpPerIOData,</span><br><span class=\"line\">            INFINITE);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rc == FALSE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            error = <span class=\"number\">123</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lpPerIOData == NULL)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                DWORD lastError = GetLastError();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lastError == WAIT_TIMEOUT)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//continue;</span></span><br><span class=\"line\">                    <span class=\"comment\">//程序结束</span></span><br><span class=\"line\">                    assert(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> lastError;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (GetNetResult(lpPerIOData, dwBytesTransferred) == FALSE)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    error = WSAGetLastError();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lpPerIOData != NULL)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (lpPerIOData-&gt;opType)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> POST_READ_PKG: <span class=\"comment\">//读函数返回</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    OnIocpReadOver(*lpPerIOData, dwBytesTransferred, error);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">case</span> POST_SEND_PKG:</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    OnIocpWriteOver(*lpPerIOData, dwBytesTransferred, error);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> NetServer::OnIocpReadOver(PER_IO_OPERATION_DATA&amp; opData,</span><br><span class=\"line\">    DWORD nBytesTransfered, DWORD error)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error != NO_ERROR || nBytesTransfered == <span class=\"number\">0</span>)<span class=\"comment\">//socket出错 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Net_CloseSocket(opData.socket);</span><br><span class=\"line\">        NetPool::PutIocpData(&amp;opData);<span class=\"comment\">//数据缓冲处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        OnRcvBuffer(opData, nBytesTransfered);<span class=\"comment\">//处理接收到的数据</span></span><br><span class=\"line\">        BOOL post = PostRcvBuffer(opData.socket, &amp;opData); <span class=\"comment\">//再次读数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!post)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Net_CloseSocket(opData.socket);</span><br><span class=\"line\">            NetPool::PutIocpData(&amp;opData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>数据发送</li>\n</ol>\n<p>数据发送时，先放到发送缓冲，再发送。向完成端口投递时，每个连接同时只能有一个正在投递的操作。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BOOL NetServer::PostSendBuffer(SOCKET socket)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_clientManage.IsPostSendBuffer(socket)) <span class=\"comment\">//如果有正在执行的投递，不能再次投递</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取要发送的数据</span></span><br><span class=\"line\">    PER_IO_OPERATION_DATA *overlap = NetPool::GetIocpData(FALSE);</span><br><span class=\"line\">    <span class=\"built_in\">int</span> sendCount = m_clientManage.GetSendBuf(socket, overlap-&gt;buf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sendCount == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        NetPool::PutIocpData(overlap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    overlap-&gt;socket = socket;</span><br><span class=\"line\">    overlap-&gt;opType = POST_SEND_PKG;</span><br><span class=\"line\">    BOOL post = PostSendBuffer(socket, overlap);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!post)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Net_CloseSocket(socket);</span><br><span class=\"line\">        NetPool::PutIocpData(overlap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_clientManage.SetPostSendBuffer(socket, TRUE);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a class=\"header-anchor\" href=\"#总结\">※</a>总结</h2>\n<p>开发一个好的封装库必须有的好的思路。对复杂问题要学会分解，每个模块功能合理，适应性要强；要有模块化、层次化处理思路。如果网络库也处理业务逻辑，处理具体包协议，它就无法做到通用性。一个通用性好的库，才值得我们花费大气力去做好。我设计的这个库，用在了公司多个系统上；以后无论遇到任何网络协议，这个库都可以用得上，一劳永逸的解决网络库封装问题。</p>\n","_path":"20240808/cai-yong-wan-cheng-duan-kou-iocp-shi-xian-gao-xing-neng-wang-luo-fu-wu-qi-windows-c-ban/","_link":"https://yaoqs.github.io/20240808/cai-yong-wan-cheng-duan-kou-iocp-shi-xian-gao-xing-neng-wang-luo-fu-wu-qi-windows-c-ban/","_id":"clzpq9i0k00dwsgerg6xu3tjm"}}