{"type":"getPostByPath","data":{"title":"λ演算","date":"2024-04-28T08:10:27.000Z","description":"","categories":[],"tags":[],"content":"<ul>\n<li><a href=\"https://goodmath.blogspot.com\">Good Math/Bad Math</a>\n<ul>\n<li>cgnail\n<ul>\n<li><a href=\"https://cgnail.github.io/academic/lambda-1/\">我的最爱Lambda演算——开篇 · cgnail’s weblog</a></li>\n<li><a href=\"https://cgnail.github.io/academic/lambda-2/\">阿隆佐.丘奇的天才之作——lambda演算中的数字 · cgnail’s weblog</a></li>\n<li><a href=\"https://cgnail.github.io/academic/lambda-3/\">Lambda演算中的布尔值和选择 · cgnail’s weblog</a></li>\n<li><a href=\"https://cgnail.github.io/academic/lambda-4/\">为什么是Y？ · cgnail’s weblog</a></li>\n<li><a href=\"https://cgnail.github.io/academic/lambda-5/\">从Lambda演算到组合子演算 · cgnail’s weblog</a></li>\n<li><a href=\"https://cgnail.github.io/academic/lambda-6/\">Lambda演算的类型 · cgnail’s weblog</a></li>\n<li><a href=\"https://cgnail.github.io/academic/lambda-7/\">终章，Lambda演算建模——程序即证明！ · cgnail’s weblog</a></li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/g9yuayon/article/details/748684\">博客推荐：good math, bad math之Lambda算子简介</a>\n<ul>\n<li><a href=\"https://blog.csdn.net/g9yuayon/article/details/759778\">lambda算子简介1.a</a></li>\n<li><a href=\"https://blog.csdn.net/g9yuayon/article/details/790953\">lambda算子 1.b</a></li>\n<li><a href=\"https://blog.csdn.net/g9yuayon/article/details/1062514\">lambda算子3:阿隆佐.丘齐(Alonzo Church)的天才</a></li>\n<li><a href=\"https://blog.csdn.net/g9yuayon/article/details/1126396\">lamdba算子4：布尔值和选择</a></li>\n<li><a href=\"https://blog.csdn.net/g9yuayon/article/details/1271319\">Lambda算子5b：How of Y</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"我的最爱Lambda演算——开篇\"><a class=\"header-anchor\" href=\"#我的最爱Lambda演算——开篇\">※</a>我的最爱Lambda演算——开篇</h2>\n<p>15 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<blockquote>\n<p>原文来自<a href=\"http://goodmath.blogspot.com/\">Good Math/Bad Math</a>的系列连载，全文分7章，本篇是<a href=\"http://goodmath.blogspot.com/2006/05/my-favorite-calculus-lambda-part-1.html\">第1章</a>。中文博客<a href=\"http://blog.csdn.net/g9yuayon/article/details/748684\">负暄琐话</a>对这个系列的前6章做过翻译，强迫症表示忍受不了「下面没有了」，于是自己动手做了全套。这里只对原文做了翻译，而“负暄琐话”的版本则加上了很多掌故，使得阅读起来更有趣味性。</p>\n</blockquote>\n<p>（在这个帖子的原始版本里，我试图用一个JavaScript工具来生成MathML。但不太顺利：有几个浏览器没法正确的渲染，在RSS feed里也显示的不好。所以我只好从头开始，用简单的文本格式重新写一遍。）</p>\n<p>计算机科学，尤其是编程语言，经常倾向于使用一种特定的演算：Lambda演算（Lambda Calculus）。这种演算也广泛地被逻辑学家用于学习计算和离散数学的结构的本质。Lambda演算伟大的的原因有很多，其中包括：</p>\n<ul>\n<li>非常简单。</li>\n<li>图灵完备。</li>\n<li>容易读写。</li>\n<li>语义足够强大，可以从它开始做（任意）推理。</li>\n<li>它有一个很好的实体模型。</li>\n<li>容易创建变种，以便我们探索各种构建计算或语义方式的属性。</li>\n</ul>\n<p>Lambda演算易于读写，这一点很重要。它导致人们开发了很多极为优秀的编程语言，他们在不同程度上都基于Lambda演算：LISP，ML和Haskell语言都极度依赖于Lambda演算。</p>\n<p>Lambda演算建立在函数的概念的基础上。纯粹的Lambda演算中，一切都是函数，连值的概念都没有。但是，我们可以用函数构建任何我们需要的东西。还记得在这个博客的初期，我谈了一些关于如何建立数学的方法么？ 我们可以从无到有地用Lambda演算建立数学的整个结构。</p>\n<p>闲话少说，让我们深入的看一看LC（Lambda Calculus）。对于一个演算，需要定义两个东西：语法，它描述了如何在演算中写出合法的表达式；一组规则，让你符号化地操纵表达式。</p>\n<h2 id=\"Lambda演算的语法\"><a class=\"header-anchor\" href=\"#Lambda演算的语法\">※</a>Lambda演算的语法</h2>\n<p>Lambda演算只有三类表达式：</p>\n<ol>\n<li>函数定义：Lambda演算中的函数是一个表达式，写成：<code>lambda x . body</code>，表示“一个参数参数为<code>x</code>的函数，它的返回值为<code>body</code>的计算结果。” 这时我们说：Lambda表达式绑定了参数<code>x</code>。</li>\n<li>标识符引用（Identifier reference）：标识符引用就是一个名字，这个名字用于匹配函数表达式中的某个参数名。</li>\n<li>函数应用（Function application）：函数应用写成把函数值放到它的参数前面的形式，如<code>(lambda x . plus x x) y</code>。</li>\n</ol>\n<h3 id=\"柯里化\"><a class=\"header-anchor\" href=\"#柯里化\">※</a>柯里化</h3>\n<p>在Lambda演算中有一个技巧：如果你看一下上面的定义，你会发现一个函数（Lambda表达式）只接受一个参数。这似乎是一个很大的局限 —— 你怎么能在只有一个参数的情况下实现加法？</p>\n<p>这一点问题都没有，因为函数就是值。你可以写只有一个参数的函数，而这个函数返回一个带一个参数的函数，这样就可以实现写两个参数的函数了——本质上两者是一样的。这就是所谓的柯里化（Currying），以伟大的逻辑学家Haskell Curry命名。</p>\n<p>例如我们想写一个函数来实现<code>x + y</code>。我们比较习惯写成类似：<code>lambda x y . plus x y</code>之类的东西。而采用单个参数函数的写法是：我们写一个只有一个参数的函数，让它返回另一个只有一个参数的函数。于是<code>x + y</code>就变成一个单参数<code>x</code>的函数，它返回另一个函数，这个函数将<code>x</code>加到它自己的参数上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda x. ( lambda y. plus x y )</span><br></pre></td></tr></table></figure>\n<p>现在我们知道，添加多个参数的函数并没有真正添加任何东西，只不过简化了语法，所以下面继续介绍的时候，我会在方便的时候用到多参数函数。</p>\n<h3 id=\"自由标识符-vs-绑定标识符\"><a class=\"header-anchor\" href=\"#自由标识符-vs-绑定标识符\">※</a>自由标识符 vs. 绑定标识符</h3>\n<p>有一个重要的语法问题我还没有提到：闭包（closure）或者叫完全绑定（complete binding）。在对一个Lambda演算表达式进行求值的时候，不能引用任何未绑定的标识符。如果一个标识符是一个闭合Lambda表达式的参数，我们则称这个标识符是（被）绑定的；如果一个标识符在任何封闭上下文中都没有绑定，那么它被称为自由变量。</p>\n<ul>\n<li><code>lambda x . plus x y</code>：在这个表达式中，<code>y</code>和<code>plus</code>是自由的，因为他们不是任何闭合的Lambda表达式的参数；而<code>x</code>是绑定的，因为它是函数定义的闭合表达式<code>plus x y</code>的参数。</li>\n<li><code>lambda x y . y x</code> ：在这个表达式中<code>x</code>和<code>y</code>都是被绑定的，因为它们都是函数定义中的参数。</li>\n<li><code>lambda y . (lambda x . plus x y)</code>：在内层演算<code>lambda x . plus x y</code>中，<code>y</code>和<code>plus</code>是自由的，<code>x</code>是绑定的。在完整表达中，<code>x</code>和<code>y</code>是绑定的：<code>x</code>受内层绑定，而<code>y</code>由剩下的演算绑定。<code>plus</code>仍然是自由的。</li>\n</ul>\n<p>我们会经常使用<code>free(x)</code>来表示在表达式<code>x</code>中自由的标识符。</p>\n<p>一个Lambda演算表达式只有在其所有变量都是绑定的时候才完全合法。但是，当我们脱开上下文，关注于一个复杂表达式的子表达式时，自由变量是允许存在的——这时候搞清楚子表达式中的哪些变量是自由的就显得非常重要了。</p>\n<h2 id=\"Lambda演算运算法则\"><a class=\"header-anchor\" href=\"#Lambda演算运算法则\">※</a>Lambda演算运算法则</h2>\n<p>Lambda演算只有两条真正的法则：称为Alpha和Beta。Alpha也被称为「转换」，Beta也被称为「规约」。</p>\n<h3 id=\"Alpha转换\"><a class=\"header-anchor\" href=\"#Alpha转换\">※</a>Alpha转换</h3>\n<p>Alpha是一个重命名操作; 基本上就是说，变量的名称是不重要的：给定Lambda演算中的任意表达式，我们可以修改函数参数的名称，只要我们同时修改函数体内所有对它的自由引用。</p>\n<p>所以 —— 例如，如果有这样一个表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda x . if (= x 0) then 1 else x ^ 2 </span><br></pre></td></tr></table></figure>\n<p>我们可以用Alpha转换，将<code>x</code>变成<code>y</code>（写作<code>alpha[x / y]</code>），于是我们有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda y . if (= y 0) then 1 else y ^ 2 </span><br></pre></td></tr></table></figure>\n<p>这样丝毫不会改变表达式的含义。但是，正如我们将在后面看到的，这一点很重要，因为它使得我们可以实现比如递归之类的事情。</p>\n<h3 id=\"Beta规约\"><a class=\"header-anchor\" href=\"#Beta规约\">※</a>Beta规约</h3>\n<p>Beta规约才是精彩的地方：这条规则使得Lambda演算能够执行任何可以由机器来完成的计算。</p>\n<p>Beta基本上是说，如果你有一个函数应用，你可以对这个函数体中和对应函数标识符相关的部分做替换，替换方法是把标识符用参数值替换。这听起来很费解，但是它用起来却很容易。</p>\n<p>假设我们有一个函数应用表达式：“ <code>(lambda x . x + 1) 3</code> “。所谓Beta规约就是，我们可以通过替换函数体（即“<code>x + 1</code>”）来实现函数应用，用数值“<code>3</code>”取代引用的参数“<code>x</code>”。于是Beta规约的结果就是“<code>3 + 1</code>”。</p>\n<p>一个稍微复杂的例子：<code>(lambda y . (lambda x . x + y)) q</code>。 这是一个挺有意思的表达式，因为应用这个Lambda表达式的结果是另一个Lambda表达式：也就是说，它是一个创建函数的函数。这时候的Beta规约，需要用标识符“<code>q</code>”替换所有的引用参数“<code>y</code>”。所以，其结果是“ <code>lambda x . x + q</code> “。</p>\n<p>再给一个让你更不爽的例子：“ <code>(lambda x y. x y) (lambda z . z * z) 3</code> “。这是一个有两个参数的函数，它(的功能是)把第一个参数应用到第二个参数上。当我们运算时，我们替换第一个函数体中的参数“<code>x</code>”为“<code>lambda z . z * z</code> “；然后我们用“<code>3</code>”替换参数“<code>y</code>”，得到：“ <code>(lambda z . z * z) 3</code> “。 再执行Beta规约，有“<code>3 * 3</code>”。</p>\n<p>Beta规则的形式化写法为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda x . B e = B[x := e] if free(e) subset free(B[x := e]) </span><br></pre></td></tr></table></figure>\n<p>最后的条件“<code>if free(e) subset free(B[x := e])</code>”说明了为什么我们需要Alpha转换：我们只有在不引起绑定标识符和自由标识符之间的任何冲突的情况下，才可以做Beta规约：如果标识符“<code>z</code>”在“<code>e</code>”中是自由的，那么我们就需要确保，Beta规约不会导致“<code>z</code>”变成绑定的。如果在“<code>B</code>”中绑定的变量和“<code>e</code>”中的自由变量产生命名冲突，我们就需要用Alpha转换来更改标识符名称，使之不同。</p>\n<p>例子更能明确这一点：假设我们有一个函数表达式，“ <code>lambda z . (lambda x . x + z)</code> “，现在，假设我们要应用它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lambda z . (lambda x . x + z)) (x + 2) </span><br></pre></td></tr></table></figure>\n<p>参数“<code>(x + 2)</code>”中，<code>x</code>是自由的。现在，假设我们不遵守规则直接做Beta规约。我们会得到：</p>\n<p>原先在“<code>x + 2</code>”中自由的的变量现在被绑定了。再假设我们应用该函数：</p>\n<p>通过Beta规约，我们会得到“<code>3 + 3 + 2</code>”。</p>\n<p>如果我们按照应有的方式先采用Alpha转换，又该如何？</p>\n<ul>\n<li>由 <code>alpha[x/y]</code> 有: <code>(lambda z . (lambda y . y + z)) (x + 2)</code></li>\n<li>由Beta规约： <code>(lambda y . y + x + 2) 3</code></li>\n<li>再由Beta规约： <code>3 + x + 2</code> 。</li>\n</ul>\n<p>“<code>3 + x + 2</code>”和“<code>3 + 3 + 2</code>”是非常不同的结果！</p>\n<p>规则差不多就是这些。还有另外一个规则，你可以选择性地加一条被称为Eta-规约的规则，不过我们将跳过它。 我在这里描述了一个图灵完备 —— 完整有效的计算系统。 要让它变得有用，或看它如何用来做些有实际意义的事情，我们还需要定义一堆能让我们做数学计算的基本函数，条件测试，递归等，我将在下一篇文章讨论这些。</p>\n<p>我们也还没有定义Lambda-演算的模型呢。（原作者在<a href=\"http://goodmath.blogspot.com/2006/04/more-logic-models-and-why-they-matter.html\">这里</a>和<a href=\"http://goodmath.blogspot.com/2006/04/correcting-my-models-post-or-why.html\">这里</a>讨论了模型的概念。）模型实际上是非常重要的！逻辑学家们在摆弄了LC好几年之后，才为其想出一个完整的模型，这是件非常重要的事情，因为虽然LC看起来是正确的，但在早期为它定义一个模型的尝试，却是失败的。毕竟，请记住，如果没有一个有效的模型，这意味着该系统的结果是毫无意义的！</p>\n<h2 id=\"阿隆佐-丘奇的天才之作——lambda演算中的数字\"><a class=\"header-anchor\" href=\"#阿隆佐-丘奇的天才之作——lambda演算中的数字\">※</a>阿隆佐.丘奇的天才之作——lambda演算中的数字</h2>\n<p>15 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<p>所以，现在，让我们用lambda演算干点有趣的事。首先，为了方便起见，我将介绍些语法糖（syntactic sugar）来命名函数，以便下面遇到某些复杂的事情的时候方便我们阅读。</p>\n<p>引进「全局」函数（即在我写的这些所有的关于lambda演算的介绍里都可以直接使用，而不用在每一个表达式中都声明一次这个函数的办法），我们将使用“let”表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let square = lambda x . x ^ 2 </span><br></pre></td></tr></table></figure>\n<p>这条表达式声明了一个名为“square”的函数，其定义是<code>lambda x . x ^ 2</code>。如果我们有“ <code>square 4</code>”，则上面的“let”表达式的等效表达式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lambda square . square 4) (lambda x . x ^ 2) </span><br></pre></td></tr></table></figure>\n<p>某些例子中，我使用了数字和算术运算。但数字并不真正存在于lambda演算中，我们有的只有函数！因此，我们需要发明某种使用函数来创建数字的方式。幸运的是，邱奇（Alonzo Church），这个发明了lambda演算的天才，找出了做到这一点的办法。他的函数化的数字的版本被称为丘奇数（Church Numerals）。</p>\n<p>所有的丘奇数都是带有两个参数的函数：</p>\n<ul>\n<li>0是“ <code>lambda s z . z</code> “。</li>\n<li>1是“ <code>lambda s z . s z</code> “。</li>\n<li>2是“ <code>lambda s z . s (s z)</code></li>\n<li>对于任何数“<code>n</code>”，它的丘奇数是将其第一个参数应用到第二个参数上“<code>n</code>”次的函数。</li>\n</ul>\n<p>一个很好的理解办法是将“<code>z</code>”作为是对于零值的命名，而“<code>s</code>”作为后继函数的名称。因此，0是一个仅返回“0”值的函数；1是将后继函数运用到0上一次的函数；2则是将后继函数应用到零的后继上的函数，以此类推。</p>\n<p>现在看好了，如果我们想要做加法，<code>x + y</code>，我们需要写一个有四个参数的函数；两个需要相加的数字；以及推导数字时用到的“<code>s</code>”和“<code>z</code>”：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let add = lambda s z x y . x s (y s z) </span><br></pre></td></tr></table></figure>\n<p>让我们将其柯里化，看看是怎么回事。首先，它接受两个参数，这是我们需要做加法的两个值；第二，它需要正则化（normalize）这两个参数，以使它们都使用对0（<code>z</code>）和后继值（<code>s</code>）的绑定（即，将参数都写成<code>s</code>和<code>z</code>的组合的形式）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let add = lambda x y . (lambda s z . (x s (y s z))) </span><br></pre></td></tr></table></figure>\n<p>看下这个式子，它说的是，为了将<code>x</code>和<code>y</code>相加，先用参数“<code>s</code>”和“<code>z</code>”创建（正则化的）丘奇数“<code>y</code>”。然后应用<code>x</code>到丘奇数<code>y</code>上，这时候使用由“<code>s</code>”和“<code>z</code>”定义的丘奇数<code>y</code>。也就是说，我们得到的结果是一个函数，这个函数把自己加到另一个数字上。（要计算<code>x + y</code>，先计算 <code>y</code> 是 <code>z</code> 的几号后继，然后计算<code>x</code> 是 <code>y</code>的几号后继。）</p>\n<p>让我们再进一步看看<code>2 + 3</code>的运算过程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add (lambda s z . s (s z)) (lambda s z . s (s (s z))) news newz </span><br></pre></td></tr></table></figure>\n<p>为了更容易理解，对数字2和3做alpha变换，“2”用“s2”和“z2”代替，3用“s3”和“z3”代替：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add (lambda s2 z2 . s2 (s2 z2)) (lambda s3 z3 . s3 (s3 (s3 z3))) </span><br></pre></td></tr></table></figure>\n<p>用<code>add</code>的定义做替换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lambda x y .(lambda s z. (x s y s z))) (lambda s2 z2 . s2 (s2 z2)) (lambda s3 z3 . s3 (s3 (s3 z3))) </span><br></pre></td></tr></table></figure>\n<p>对<code>add</code>做beta规约：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda s z . (lambda s2 z2 . s2 (s2 z2)) s (lambda s3 z3 . s3 (s3 (s3 z3)) s z) </span><br></pre></td></tr></table></figure>\n<p>然后beta规约丘奇数”3”。这步操作其实是“正则化”3：把数字3的定义里的后继函数和零函数替换成<code>add</code>的参数列表里的后继函数和零函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda s z . (lambda s2 z2 . s2 (s2 z2)) s (s (s (s z))) </span><br></pre></td></tr></table></figure>\n<p>现在，到了最精妙的一步了。再对丘奇数”2”做beta规约。我们知道：2是一个函数，它接受两个参数：一个后继函数和0(函数)。于是，要相加2和3，我们用后继函数应用到2的第一个参数；用3的运算结果应用到第二个参数（0函数）！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda s z . s (s (s (s (s z)))) </span><br></pre></td></tr></table></figure>\n<p>于是，我们的结果是：丘奇数”5”！</p>\n<h2 id=\"Lambda演算中的布尔值和选择\"><a class=\"header-anchor\" href=\"#Lambda演算中的布尔值和选择\">※</a>Lambda演算中的布尔值和选择</h2>\n<p>15 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<p>现在，我们在lambda演算中引入了数字，只差两件事情就可以表达任意计算了：一个是如何表达选择（分支），另一个是如何表示重复。在这篇文章中，我将讨论布尔值和选择，下一篇将介绍重复和递归。</p>\n<p>我们希望能够写出形如 <code>if / then / else</code>语句的表达式，就像我们在大多数编程语言做的那样。继像丘奇数那样将数字表示为函数之后，我们也将true和false值表示为对其参数执行一个if-then-else操作的函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let TRUE = lambda x y . x </span><br><span class=\"line\">let FALSE = lambda x y . y </span><br></pre></td></tr></table></figure>\n<p>于是，现在我们可以写一个“<code>if</code>”函数，它的第一个参数是一个条件表达式，第二个参数是如果条件为真时才进行运算的表达式，第三个参数则如果条件为假时要进行的运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let IfThenElse = lambda cond true_expr false_expr . cond true_expr false_expr </span><br></pre></td></tr></table></figure>\n<p>此外我们还需要定义常用的逻辑运算：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let BoolAnd = lambda x y . x y FALSE </span><br><span class=\"line\">let BoolOr = lambda x y. x TRUE y </span><br><span class=\"line\">let BoolNot = lambda x . x FALSE TRUE </span><br></pre></td></tr></table></figure>\n<p>现在，就让我们过一遍这些定义。让我们先看看<code>BoolAnd</code>：</p>\n<ul>\n<li><code>BoolAnd TRUE FALSE</code>，展开TRUE和FALSE定义：<code>BoolAnd (lambda x y . x) (lambda x y . y)</code></li>\n<li>alpha变换true和false：<code>BoolAnd (lambda xt yt . xt) (lambda xf yf . yf)</code></li>\n<li>现在，展开BoolAnd：<code>(lambda x y. x y FALSE) (lambda xt yt . xt) (lambda xf yf . yf)</code></li>\n<li>beta规约：<code>(lambda xt yt.xt) (lambda xf yf. yf) FALSE</code></li>\n<li>再次beta规约：<code>(lambda xf yf . yf)</code></li>\n</ul>\n<p>于是我们得到结果：<code>BoolAnd TRUE FALSE = FALSE</code>。再让我们来看看<code>BoolAnd FALSE TRUE</code>：</p>\n<ul>\n<li><code>BoolAnd (lambda x y . y) (lambda x y .x)</code></li>\n<li>alpha变换：<code>BoolAnd (lambda xf yf . yf) (lambda xt yt . xt)</code></li>\n<li>展开BoolAnd： <code>(lambda x y .x y FALSE) (lambda xf yf . yf) (lambda xt yt . xt)</code></li>\n<li>beta规约：<code>(lambda xf yf . yf) (lambda xt yt . xt) FALSE</code></li>\n<li>再beta规约：<code>FALSE</code></li>\n</ul>\n<p>所以，<code>BoolAnd FALSE TRUE = FALSE</code></p>\n<p>最后让我们来算算，<code>BoolAnd TRUE TRUE</code>：</p>\n<ul>\n<li>展开两个TRUE： <code>BoolAnd (lambda x y . x) (lambda x y . x)</code></li>\n<li>alpha变换： <code>BoolAnd (lambda xa ya . xa) (lambda xb yb . xb)</code></li>\n<li>展开BoolAnd： <code>(lambda x y . x y FALSE) (lambda xa ya . xa) (lambda xb yb . xb)</code></li>\n<li>beta规约： <code>(lambda xa ya . xa) (lambda xb yb . xb) FALSE</code></li>\n<li>beta规约： <code>(lambda xb yb .xb)</code></li>\n</ul>\n<p>所以，<code>BoolAnd TRUE TRUE = TRUE</code></p>\n<h2 id=\"为什么是Y？\"><a class=\"header-anchor\" href=\"#为什么是Y？\">※</a>为什么是Y？</h2>\n<p>15 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<p>在前面的几个帖子里，我已经建立了如何把lambda演算变成一个有用的系统的点点滴滴。 我们已经有了数字，布尔值和选择运算符。我们唯一欠缺的是重复。</p>\n<p>这个有点棘手。lambda演算使用递归实现循环（递归的解释可以看<a href=\"http://goodmath.blogspot.com/2006/03/clarifying-recursion.html\">这里</a>）。 但是，由于在lambda演算里函数没有名字，我们得采取一些非常手段。这就是所谓的Y组合子，又名lambda不动点运算符。</p>\n<p>让我们先来看看lambda演算之外的一个简单的递归函数。阶乘函数，这是标准的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factorial(n) = 1 if n = 0 </span><br><span class=\"line\">factorial(n) = n * factorial(n-1) if n &gt; 0 </span><br></pre></td></tr></table></figure>\n<p>如果我们要用lambda演算来写的话，我们需要几个工具……我们需要一个测试是否为零的函数，一个乘法函数，以及一个减1的函数。</p>\n<p>为了检查是否为零，我们将使用一个命名函数<code>IsZero</code>，它有三个参数：一个数字，两个值。如果数字为0，则返回第一个值；如果它不为0，则返回第二个值。</p>\n<p>对于乘法——我们在制定出递归之前写不出乘法。但我们可以假设目前有一个乘法函数 <code>Mult x y</code>。</p>\n<p>最后，减1函数，我们用<code>Pred x</code>表示<code>x</code>的前驱——即<code>x - 1</code>。</p>\n<p>所以——第一版的阶乘，如果我们把递归调用留做空白的话，将是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda n . IsZero n 1 (Mult n ( something (Pred n))) </span><br></pre></td></tr></table></figure>\n<p>现在的问题是，我们怎么填上“something”，使其递归？</p>\n<p>答案是一些所谓的组合子。一个组合子是一种特殊的高阶函数，它们只引用函数应用。（一个高阶函数是一个函数，它接受函数作为参数，并且返回的结果也是函数）。Y组合子非常特殊，它有近乎神奇的功能使得递归成为可能。它的样子如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Y = lambda y . (lambda x . y (x x)) (lambda x . y (x x)) </span><br></pre></td></tr></table></figure>\n<p>看了公式，你就就明白为什么叫它Y了，因为它的“形状”像一个Y。为了让这一点更清晰，有时我们把它写成树的形式。下面是Y组合子的树：</p>\n<p><img src=\"https://cgnail.github.io/images/y.jpg\" alt=\"y-combinator\"></p>\n<p>Y组合子的特别之处在于它应用自身来创造本身，也就是说 <code>(Y Y) = Y (Y Y)</code>。让我们从<code>(Y Y)</code>开始看看它如何工作：</p>\n<ul>\n<li><code>Y Y</code></li>\n<li>展开第一个<code>Y</code>：<code>(lambda y . (lambda x . y (x x)) (lambda x . y (x x))) Y</code></li>\n<li>现在，beta规约：<code>(lambda x . Y (x x)) (lambda x . Y (x x))</code></li>\n<li>alpha[x/z]变换第二个lambda：<code>(lambda x . Y (x x)) (lambda z. Y (z z))</code></li>\n<li>beta规约：<code>Y ((lambda z. Y (z z)) (lambda z. Y (z z)))</code></li>\n<li>展开前面的Y，并<code>alpha[y/a][x/b]</code>变换：<code>(lambda a . (lambda b . a (b b)) (lambda b . a (b b))) ((lambda z . Y (z z)) ( lambda z . Y (z z)))</code></li>\n<li>beta规约：<code>(lambda b . ((lambda z. Y (z z)) (lambda z. Y (z z))) (b b)) (lambda b . ((lambda z. Y (z z)) (lambda z. Y (z z))) (b b))</code></li>\n</ul>\n<p>现在，仔细看该表达式。这是<code>(Y (Y Y))</code> [记得前面的<code>(Y Y) = (lambda x . Y (x x)) (lambda x . Y (x x))</code>吧]。所以， <code>Y Y = Y (Y Y)</code>，这是Y的魔力：它再造了本身。<code>(Y Y) = Y (Y Y) = Y (Y (Y Y))</code>，子子孙孙无穷匮也。</p>\n<p>那么，我们如何使用这个疯狂的玩意？</p>\n<p>好吧，让我们拿我们的第一次尝试做一下修改。给它取个名字，并尝试使用该名字重写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fact = lambda n . IsZero n 1 (Mult n (fact (Pred n))) </span><br></pre></td></tr></table></figure>\n<p>现在的问题是，“fact”不是“fact”中定义的标识符。我们如何让“fact”引用“fact”呢？好了，我们可以做一个lambda抽象，让“fact”函数作为参数传过去；于是，如果我们能找到一种方法来写“fact”，使得我们可以把它作为一个参数传给它自己，事情就搞定了。我们称之为metafact。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let metafact = lambda fact . (lambda n . IsZero n 1 (Mult n (fact (Pred n)))) </span><br></pre></td></tr></table></figure>\n<p>现在，如果我们可以应用metafact到本身，我们就得到了我们的阶乘函数。也就是说，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fact n = (metafact metafact) n 。</span><br><span class=\"line\">        &lt;= (lambda f1 . lambda t1 .  t1 ? 1 : t1 * f1 (P(t1))) (lambda f2 . lambda t2 .  t2 ? 1 : t2 * f2 (P(t2))) n  </span><br><span class=\"line\">        &lt;= (lambda t1 .  t1 ? 1 : t1 * (lambda f2 . lambda t2 .  t2 ? 1 : t2 * f2 (P(t2))) (P(t1))) n</span><br><span class=\"line\">        &lt;= lambda n .  n ? 1 : n * (lambda f2 . lambda t2 .  t2 ? 1 : t2 * f2 (P(t2))) (P(n))</span><br><span class=\"line\">        &lt;= lambda n .  n ? 1 : n * (lambda f2 .  P(n) ? 1 : P(n) * f2 (P(P(n))) ) </span><br><span class=\"line\">        &lt;= lambda n .  n ? 1 : n * (lambda f .  (P(n) ? 1 : P(n) * f (P(P(n))) )</span><br><span class=\"line\">        &lt;= lambda n . n ? 1 : n * (lambda f . f (P(n)))</span><br><span class=\"line\">        &lt;= lambda f . lambda n . n ? 1 : n * f (P(n))</span><br><span class=\"line\">        &lt;= f (n)</span><br></pre></td></tr></table></figure>\n<p>这正是Y的用武之地。它让我们可以创建一个古怪的结构，每次需要递归的时候都可以复制函数过来。<code>metafact (Y metafact)</code>将得到我们想要的。展开之，这就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lambda fact . (lambda n . IsZero n 1 (Mult n (fact (Pred n))))) (Y (lambda fact . (lambda n . IsZero n 1 (Mult n (fact (Pred n)))))) </span><br></pre></td></tr></table></figure>\n<p><code>(Y metafact)</code>实际上是第一个lambda中参数fact的值；当我们对它做beta规约的时候，如果n为零，那么它只是返回1，如果它不为零，那么它调用<code>fact (Pred n)</code>。 然后再将<code>fact</code>beta规约为<code>Y metafact</code>， 这个变换疯狂地复制，得到输出<code>metafact (Y metafact) (Pred n)</code>。</p>\n<p>瞧，递归（<code>metafact (Y metafact) = metafact (Y metafact) (Pred n)</code>）。极度扭曲的递归。</p>\n<p>我第一次了解了Y组合子是在本科，1989左右，至今我仍然觉得它很神秘。我虽然也明白它是怎么来的，但我无法想象地球上怎么会有人把它给想出来！</p>\n<p>如果你对此很长感兴趣，那么我极力推荐<a href=\"http://www.amazon.com/gp/product/0262560992/ref=pd_sim_books/104-7045044-8378353?n=283155\">「The Little Schemer」</a>这本书。这是本非常棒的小书 —— 写得象一本儿童读物。书里要么每一页正面是一个问题，背面就是答案，要么一页分成两栏，一栏问题一栏答案。书的风格轻松幽默，不仅教你Scheme编程，更教人怎么思考。</p>\n<p>一个重要的提示：实际上有几个不同的版本的Y组合子。也有几种不同的lambda演算的计算方式：给定以下表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lambda x y . x * y) 3 ((lambda z . z * z) 4) </span><br></pre></td></tr></table></figure>\n<p>我们可以按不同的顺序来计算：我们可以首先对<code>(lambda x y . x * y)</code>做beta规约，于是有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 * ((lambda z . z * z) 4) </span><br></pre></td></tr></table></figure>\n<p>或者，我们可以先beta规约<code>((lambda z . z * z) 4)</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lambda x y . x * y) 3 (4 * 4) </span><br></pre></td></tr></table></figure>\n<p>在这种情况下，两种方式得到相同的结果；但事实并非总是如此。</p>\n<p>第一种顺序就是我们所说的「惰性求值」（Lazy evaluation）：我们不计算函数的参数，直到我们需要使用它们。第二种叫「急切求值」（eager evaluation）：我们总是在把参数传递给函数之前进行计算。（在实际的编程语言中，Lisp语言，Scheme，和ML使用急切求值计算lambda演算，Haskell和Miranda则使用惰性值计算lambda演算。）我上面描述的Y组合子是惰性求值。如果我们用急切求值，那么上述Y组合子是导不出来的——事实上，它会永远地复制Y。</p>\n<h2 id=\"一点个人解释\"><a class=\"header-anchor\" href=\"#一点个人解释\">※</a>一点个人解释</h2>\n<h2 id=\"Y在定义递归函数中的作用\"><a class=\"header-anchor\" href=\"#Y在定义递归函数中的作用\">※</a>Y在定义递归函数中的作用</h2>\n<p>首先，在lambda演算中，函数名不是不可缺少的，没有函数名的函数称为「匿名函数」。lambda符号的引入就是为了去掉函数名这个冗余，使定义匿名函数成为可能。但是当需要定义的函数含有递归时，比如阶乘<code>factorial</code>，也就是函数的定义部分需要引用函数自身的时候，没有函数名意味着用lambda演算无法直接引用函数自身。怎么办呢？</p>\n<p>一种办法是设计另一个函数G，它接受一个函数作为参数，返回值也是一个函数（这种参数是函数的函数称为高阶函数）。然后，我们把<code>factorial</code>当做参数传给G，如果G返回的函数也是<code>factorial</code>的话，就圆满了。也就是说，这个G需要满足两个特征：</p>\n<ol>\n<li>G的定义中不会出现<code>factorial</code>，但是它可以接受<code>factorial</code>作为参数。回想一下一阶函数<code>f(x) = x * x</code>，它的定义里没有出现数字「1」，但是「1」可以传给它进行计算。而在构造G时，<code>factorial</code>就相当于数字「1」。</li>\n<li>方程<code>G(f)=f</code>的解是<code>factorial</code>。这样我们就不用直接定义<code>factorial</code>，求解这个关于G的方程就可以得到<code>factorial</code>的定义了。</li>\n</ol>\n<p>于是，我们需要干两件事：找到G，和找到求解<code>G(f)=f</code>的办法。寻找G很简单，既然我们想让<code>G(factorial)=factorial</code>，那么把<code>factorial</code>定义中关于<code>factorial</code>的引用参数化就可以了，即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let G = lambda f . lambda n . IsZero n 1 (Mult n ( f (Pred n))) </span><br></pre></td></tr></table></figure>\n<p>这就是上面的<code>metafact</code>函数。这种构造方法可以用于构造任意递归函数的「G」。</p>\n<p>然后我们需要找到求解方程<code>G(f)=f</code>的办法。满足<code>f(x)=x</code>的x称为函数<code>f</code>的不动点，<code>f</code>是高阶函数时也不例外。Y组合子的作用就是计算函数的不动点，它对所有的函数<code>f</code>都满足<code>f(Y(f)) = Y(f)</code>，推理如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y (f) = (lambda y . (lambda x . y (x x)) (lambda x . y (x x))) f</span><br><span class=\"line\">    = (lambda x . f (x x)) (lambda x . f (x x)) </span><br><span class=\"line\">    = (lambda x . f (x x)) (lambda a . f (a a))</span><br><span class=\"line\">    = f ((lambda a . f (a a)) (lambda a . f (a a)))</span><br><span class=\"line\">    = f ((lambda x . f (x x)) (lambda x . f (x x)))</span><br><span class=\"line\">    = f (Y(f))</span><br></pre></td></tr></table></figure>\n<p>于是，<code>factorial</code>的定义就可以写成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factorial n = (Y metafact) n </span><br><span class=\"line\">            = &#123;[lambda y . (lambda t . y (t t)) (lambda t . y (t t))]</span><br><span class=\"line\">               [lambda f . lambda n . IsZero n 1 (Mult n ( f (Pred n)))]&#125; n</span><br></pre></td></tr></table></figure>\n<p>这下不用引用自身了。</p>\n<h2 id=\"Y怎么来的\"><a class=\"header-anchor\" href=\"#Y怎么来的\">※</a>Y怎么来的</h2>\n<p>现在回到第一版的阶乘。我们虽然不能直接引用自身，但可以把它作为参数传进来，也就是说：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fact2 = lambda f. lambda n . IsZero n 1 (Mult n ( f (Pred n))) </span><br></pre></td></tr></table></figure>\n<p>这样，在计算5的阶乘时，我们只需要计算<code>fact2(fact2, 5)</code>就可以了。定义并没有引用自身，只是在使用的时候把自己当参数传过去。是不是很简单？</p>\n<p>但是，这个计算式是错误的：fact2的定义要求它接受两个参数，其中参数f是只接受一个参数的函数，于是计算式中第二个的fact2在参数数量上是无法和定义中的f匹配的。那怎么办？</p>\n<p>不要紧，我们可以修改一下f的形式，让它接受两个参数。即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fact3 = lambda f. lambda n . IsZero n 1 (Mult n ( f [f, (Pred n)])) </span><br></pre></td></tr></table></figure>\n<p>这下计算<code>fact3(fact3, 5)</code>就不会出错了。除了这个定义有点丑……</p>\n<p>如果对fact3做下化简又如何呢？首先是对拥有两个参数的f进行柯里化变换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fact3 = lambda h . lambda n . IsZero n 1 (Mult n ( h h (Pred n))) </span><br><span class=\"line\">          = lambda h . lambda n . IsZero n 1 (Mult n ( (h h) (Pred n)))</span><br></pre></td></tr></table></figure>\n<p>这样计算阶乘的方式也相应变成了<code>(fact3 fact3) 5</code>。接着把<code>(h h)</code>用函数<code>q</code>代替，则有</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fact3 = lambda h . lambda n . [lambda q . IsZero n 1 (Mult n ( q (Pred n)))] (h h)</span><br><span class=\"line\">          = lambda h . [lambda n . lambda q . IsZero n 1 (Mult n ( q (Pred n)))] (h h)</span><br></pre></td></tr></table></figure>\n<p>仔细观察中括号部分，参数h对于这部分是完全自由的，于是我们可以用另一个函数定义替换之：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f0 = lambda n . lambda q . IsZero n 1 (Mult n ( q (Pred n)))</span><br><span class=\"line\">let fact3 = lambda h . f0 (h h)</span><br></pre></td></tr></table></figure>\n<p>是不是觉得<code>f0</code>眼熟？没错，这就是<code>metafact</code>！不过我们先把<code>f0</code>放一边，看看如何使用这个定义计算n的阶乘。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factorail n = (fact3 fact3) n </span><br><span class=\"line\">            = (lambda h . f0 (h h)) (lambda h . f0 (h h)) n</span><br></pre></td></tr></table></figure>\n<p>把上面的式子写成 <code>function_name x</code>的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factorial n = &#123;[lambda f . (lambda h . f (h h)) (lambda h . f (h h))] f0&#125; n</span><br></pre></td></tr></table></figure>\n<p>注意大括号中的部分，是不是更眼熟了？这就是Y的定义。真是怎么绕都扰不过去的Y啊……</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">factorial n = &#123;[lambda f . (lambda h . f (h h)) (lambda h . f (h h))] f0&#125; n</span><br><span class=\"line\">            = &#123;Y f0&#125; n</span><br><span class=\"line\">            = (Y metafact) n</span><br></pre></td></tr></table></figure>\n<h2 id=\"从Lambda演算到组合子演算\"><a class=\"header-anchor\" href=\"#从Lambda演算到组合子演算\">※</a>从Lambda演算到组合子演算</h2>\n<p>15 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<p>在昨天介绍了Lambda演算中的Y组合子（Y Combinator）之后，我认为展示一些你可以用组合子做的有趣的和有用的东西会比较有意思。</p>\n<p>让我们来看看三个简单的组合子：</p>\n<ul>\n<li><code>S</code>：<code>S</code>是一个函数应用组合子： <code>S = lambda x y z . (x z (y z))</code></li>\n<li><code>K</code>：<code>K</code>生成一个返回特定常数值的函数： <code>K = lambda x . (lambda y . x)</code>。 （即扔掉第二个参数，返回第一个参数）</li>\n<li><code>I</code>：恒等函数： <code>I = lambda x . x</code></li>\n</ul>\n<p>乍一看，这是一个很奇怪的组合。<code>S</code>的应用机制尤为奇怪 —— 它并不是接受两个参数<code>x</code>和<code>y</code>，并应用<code>x</code>到<code>y</code>，它除了<code>x</code>和<code>y</code>外还用到了第三个值<code>z</code>，先将<code>x</code>应用到<code>z</code>上，再将<code>y</code>应用到<code>z</code>上，最后用前者的结果应用到了后者的结果上。</p>\n<p>这是有道理的。以下各行各做了一步规约：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S K K x = </span><br><span class=\"line\">(K x) (K x) = </span><br><span class=\"line\">x </span><br></pre></td></tr></table></figure>\n<p>噗！ 我们根本用不着<code>I</code>。我们仅用<code>S</code>和<code>K</code>就创建了<code>I</code>的等价。但是，这仅仅是个开始：事实上，我们可以只用S和K组合子，甚至一个变量都不用，创建任意lambda演算表达式的等价。</p>\n<p>例如，Y组合子可以写成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y = S S K (S (K (S S (S (S S K)))) K) </span><br></pre></td></tr></table></figure>\n<p>在我们继续深入之前，有一个重要的事情要指出。我在上面说的是，使用<code>S K K</code>，我们创建了<code>I</code>的<em>等价</em>，然而它并没有规约为<code>lambda x . x</code>。</p>\n<p>到目前为止，我们说在Lambda演算中，“<code>x = y</code>”，当且仅当<code>x</code>和<code>y</code>相同，或通过Alpha转化后相同。（这样<code>lambda x y . x + y</code>等于<code>lambda a b . a + b</code> ，但不等于<code>lambda x y . y + x</code> ）这就是所谓的内涵等价(intensional equivalence) 。 然而，另一种相等也非常有用，这就是所谓的外延等价（extensional equivalence）或外延相等（extensional equality）。外延相等时，表达式<code>X</code>等于一个表达式<code>Y</code>，当且仅当<code>X</code>等同<code>Y</code>（模Alpha），或者 <code>for all a . X a = Y a</code>。</p>\n<p>从现在起，我们使用「<code>=</code>」表示外延相等。我们可以将任何 Lambda表达式转换为外延相等的组合子形式。我们定义一个从Lambda形式到组合子形式的变换函数<code>C</code>：</p>\n<ol>\n<li><code>C&#123;x&#125; = x</code></li>\n<li><code>C&#123;E1 E2&#125; = C&#123;E1&#125; C&#123;E2&#125;</code></li>\n<li><code>C&#123;lambda x . E&#125; = K C&#123;E&#125;</code>，如果<code>x</code>在<code>E</code>中非自由</li>\n<li><code>C&#123;lambda x . x&#125; = I</code></li>\n<li><code>C&#123;lambda x . E1 E2&#125; = (S C&#123;lambda x . E1&#125; C &#123;lambda x . E2&#125;)</code></li>\n<li><code>C&#123;lambda x . (lambda y . E)&#125; = C &#123;lambda x . C &#123;lambda y . E&#125;&#125;</code>，如果<code>x</code>在<code>E</code>中是自由变量</li>\n</ol>\n<p>让我们演进一下 <code>C&#123;lambda x y . y x&#125;</code> ：</p>\n<ul>\n<li>柯里化函数： <code>C&#123;lambda x . (lambda y . y x)&#125;</code></li>\n<li>根据规则6： <code>C&#123;lambda x . C&#123;lambda y . y x&#125;&#125;</code></li>\n<li>根据规则5： <code>C&#123;lambda x . S C&#123;lambda y . y&#125; C&#123;lambda y . x&#125;&#125;</code></li>\n<li>根据规则4： <code>C&#123;lambda x . S I C&#123;lambda y . x&#125;&#125;</code></li>\n<li>根据规则3： <code>C&#123;lambda x . S I (K C&#123;x&#125;)&#125;</code></li>\n<li>通过规则1： <code>C&#123;lambda x . S I (K x)&#125;</code></li>\n<li>根据规则5： <code>S C&#123;lambda x . S I&#125; C&#123;lambda x . (K x)&#125;</code></li>\n<li>根据规则3： <code>S (K (S I)) C&#123;lambda x . K x&#125;</code></li>\n<li>根据规则5： <code>S (K (S I)) (S C&#123;lambda x . K&#125; C&#123;lambda x . x&#125;)</code></li>\n<li>通过规则1： <code>S (K (S I)) (S C&#123;lambda x . K&#125; I)</code></li>\n<li>根据规则3： <code>S (K (S I)) (S (K K) I)</code></li>\n</ul>\n<p>现在，让我们尝试使用“<code>x</code>”和“<code>y</code>”作为参数传递给该组合子表达式，并规约：</p>\n<ul>\n<li><code>S (K (S I)) (S (K K) I) x y</code></li>\n<li>让我们创建一些别名，以方便阅读：<code>A = (K (S I)), B = (S (K K) I)</code>，所以我们的表达式现在成了：<code>S A B x y</code></li>\n<li>展开S: <code>(A x (B x)) y</code></li>\n<li>让我们去掉别名B：<code>(A x ((S (K K) I) x)) y</code></li>\n<li>现在让我们去掉S：<code>(A x ((K K) x (I x))) y</code></li>\n<li>以及I：<code>(A x ((K K) x x)) y</code></li>\n<li>规约<code>(K K) x</code> ：<code>(A x (K x)) y</code></li>\n<li>展开别名A： <code>((K (S I)) x (K x)) y</code></li>\n<li>规约<code>(K (S I)) x</code> ，得到： <code>((S I) (K x)) y</code></li>\n<li>规约S：<code>I y (K x) y</code></li>\n<li>规约I：<code>y (K x) y</code></li>\n<li>最后规约<code>(K x) y</code>，剩下：<code>y x</code></li>\n</ul>\n<p>就是这样。好玩吧？</p>\n<h2 id=\"Lambda演算的类型\"><a class=\"header-anchor\" href=\"#Lambda演算的类型\">※</a>Lambda演算的类型</h2>\n<p>16 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<p>我们已经掌握了直觉逻辑（<a href=\"http://goodmath.blogspot.com/2006/05/logic-fun-intuitionistic-logic.html\">Intuitionistic Logic</a>，IL），我们再回到lambda演算：我们已经得到了我们需要定义模型的逻辑工具。 当然，在没有更简单的事情了，对吧？</p>\n<p>到目前为止我们讨论的都是简单的无类型lambda演算。一如丘奇首次提出LC的第一个版本。但它存在一些问题，为了解决这些问题，人们引入了「类型」（type）的概念，于是出现了简单类型lambda演算，之后出现了各种变种 —— SystemT，SystemF，Lambda立方（和<a href=\"http://zh.wikipedia.org/wiki/%E6%99%82%E9%96%93%E7%AB%8B%E6%96%B9\">时间立方</a>没啥关系:-)）等等。最终，人们意识到无类型lambda演算实际上是类型化lambda演算的一个简单到病态的特例 —— 只有一个类型的LC。</p>\n<p>lambda演算的语义在类型化演算中最容易理解。现在，我们来看看最简单的类型化LC，叫做「简单类型化lambda演算」（simply typed lambda calculus）；以及它如何在语义上等同于直觉逻辑。（其实上，每个种类型化LC都对应于一种IL，而且每个LC中的beta规约都对应于IL中的一步推理，这就是为什么我们需要先跑去介绍直觉逻辑，然后再回到这里。）</p>\n<p>类型化lambda演算的主要变化是增加了一个叫做「基类型」（base types）的概念。在类型化lambda演算中，你可以使用一些由原子值构成的论域（universe）， 这些值分为不同的简单类型。基类型通常由单个的小写希腊字母命名，然而这正好是Blogger的痛处（普通html文本打不出希腊字母），我只好用大写英文字母来代替类型名称。因此，例如，我们可以有一个类型「N」，它由包含了自然数集合，也可以有一个类型「B」，对应布尔值true / false，以及一个对应于字符串类型的类「S」。</p>\n<p>现在我们有了基本类型，接下来我们讨论函数的类型。函数将一种类型（参数的类型）的值映射到的第二种类型（返回值的类型）的值。对于一个接受类型A的输入参数，并且返回类型B的值的函数，我们将它的类型写为A -&gt; B 。「 -&gt;」叫做函数类型构造器（function type constructor），它是右关联的，所以 A -&gt; B -&gt; C 表示 A -&gt; (B -&gt; C)。</p>\n<p>为了将类型应用于lambda演算，我们还要做几件事情。首先，我们需要更新语法，使我们可以包含类型信息。第二，我们需要添加一套规则，以表示哪些类型化程序是合法的。</p>\n<p>语法部分很简单。我们添加了一个「:」符号； 冒号左侧是表达式或变量的绑定，其右侧是类型规范。 它表明，其左侧拥有其右侧指定的类型。举几个例子：</p>\n<ul>\n<li><code>lambda x : N . x + 3</code>。表示参数<code>x</code> 类型为<code>N</code> ，即自然数。这里没有指明函数的结果的类型；但我们知道，函数「+」的类型是 <code>N -&gt; N</code> ，于是可以推断，函数结果的类型是N。</li>\n<li><code>(lambda x . x + 3) : N -&gt; N</code>，这和上面一样，但类型声明被提了出来，所以它给出了lambda表达式作为一个整体的类型。这一次我们可以推出 <code>x : N</code> ，因为该函数的类型为 <code>N -&gt; N</code>，这意味着该函数参数的类型为 N 。</li>\n<li><code>lambda x : N, y : B . if y then x * x else x</code>。这是个两个参数的函数，第一个参数类型是 N ，第二个的类型是 B 。我们可以推断返回类型为 N 。于是整个函数的类型是 <code>N -&gt; B -&gt; N</code> 。乍看之下有点奇怪；但请记住，lambda演算实际上只有单个参数；多参数函数的写法只是柯里化的简写。所以实际上这个函数是：<code>lambda x : N . (lambda y : B . if y then x * x else x)</code>；内层lambda的类型是 <code>B -&gt; N</code> ; 外层类型是 <code>N -&gt; (B -&gt; N)</code>。</li>\n</ul>\n<p>为了讨论程序是否关于类型合法（即「良类型的」(well-typed) ），我们需要引入一套类型推理规则。当使用这些规则推理一个表达式的类型时，我们称之为类型判断（type judgement）。类型推理和判断使我们能推断lambda表达式的类型；如果表达式的任一部分和类型判断结果不一致，则表达式非法。（丘奇开始研究类型化LC的动机之一是区分「原子」值和「谓词」值，他通过使用类型以确保谓词不能操作谓词，以试图避免的哥德尔式的悖论。）</p>\n<p>我将采用一套不太正规的符号表示类型判断；标准符号太难用我目前使用的软件渲染了。常用的符号跟分数有点像；分子由我们已知为真的语句组成；分母则是我们可以从分子中推断出来的东西。 我们经常在分子中使用一个叫「上下文」（context）的概念，它包含了一组我们已知为真的语句，通常表示为一个大写的希腊字母。这里我用大写的希腊字母的名称表示。如果一个类型上下文包含声明”<code>x : A</code>，我会写成 <code>CONTEXT |- x : A</code>。对于分数形式的推理符号，我用两行表示，分子一行标有「Given: 」，分母一行标有「Infer: 」。 （正常符号用法可以访问<a href=\"http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus\">维基百科的STLC</a>页 。）</p>\n<p>**规则1：（类型标识） **</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given: nothing </span><br><span class=\"line\">Infer: x : A |- x : A </span><br></pre></td></tr></table></figure>\n<p>最简单的规则：如果我们只知道变量的类型声明，那么我们知道这个变量是它所声明的类型。</p>\n<p>**规则2：（类型不变式） **</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given: GAMMA |- x : A, x != y </span><br><span class=\"line\">Infer: (GAMMA + y : B) |- x : A </span><br></pre></td></tr></table></figure>\n<p>这是不干涉语句。 如果我们知道 <code>x : A</code>，那么我们可以推断出其他任何类型判断都不能改变我们对<code>x</code>的类型推断。</p>\n<p>规则3：（参数到函数的推理）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given: (GAMMA + x : A) |- y : B </span><br><span class=\"line\">Infer: GAMMA |- (lambda x : A . y) : A -&gt; B </span><br></pre></td></tr></table></figure>\n<p>这个语句使我们能够推断函数的类型：如果我们知道函数参数的类型是 <code>A</code>，而且该函数返回值的类型是 <code>B</code> ，那么我们可以推出函数的类型为 <code>A -&gt; B</code> 。</p>\n<p>最后，Rule4：（函数应用推理）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given: GAMMA |- x : A -&gt; B, GAMMA |- y : A </span><br><span class=\"line\">Infer: GAMMA |- (x y) : B </span><br></pre></td></tr></table></figure>\n<p>如果我们知道一个函数的类型为 <code>A -&gt; B</code> ，且把它应用到类型为<code>A</code>的值上，那么结果是类型为 <code>B</code> 的表达式。</p>\n<p>规则就是这四个。如果我们有一个lambda表达式，且表达式中每一项的类型判断都保持一致，那么表达式就是良类型化的（well-typed）。如果不是，则表达式非法。</p>\n<p>下面我们找点刺激，描述下SKI组合子的类型。这些都是不完整的类型——我用的是类型变量，而不是具体的类型。 在真正使用组合子的程序中，你可以找到实际类型来替换类型变量。 别担心，我会用一个例​​子来阐明这一点。</p>\n<ul>\n<li><code>I</code>组合子： <code>(lambda x . x) : A -&gt; A</code></li>\n<li><code>K</code>组合子： <code>(lambda x : A . ((lambda y : B . x) : B -&gt; A)): A -&gt; B -&gt; A</code></li>\n<li><code>S</code>组合子： <code>(lambda x : A -&gt; B-&gt; C . (lambda y : A -&gt; B . (lambda z : A . (x z : B -&gt; C) (y z : B)))) : (A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; C</code></li>\n</ul>\n<p>现在，让我们来看一个简单的lambda演算表达式：<code>lambda x y . y x</code>。由于没有任何关于类型的声明或参数，我们无法知道确切的类型。但是，我们知道，<code>x</code>一定具有某种类型，我们称之为<code>A</code>；而且我们知道，<code>y</code>是一个函数，它以<code>x</code>作为应用的参数，所以它的参数类型为<code>A</code>，但它的结果类型是未知的。因此，利用类型变量，我们有 <code>x : A, y : A -&gt; B</code>。我们可以通过看分析完整的具体表达式来确定<code>A</code> 和 <code>B</code> 。所以，让我们用<code>x = 3</code>，和<code>y = lambda a : N. a * a</code> 来计算类型。假设我们的类型上下文已经包含了 <code>*</code> 的类型为 “<code>N -&gt; N -&gt; N</code>“。</p>\n<ul>\n<li><code>(lambda x y . y x) 3 (lambda a : N . a * a)</code></li>\n<li>3是整数，所以它的类型是： <code>3 : N</code> 。</li>\n<li>根据规则4，我们可以推出出表达式 <code>a * a</code> 的类型是 <code>N</code>，其中 <code>a : N</code> （<code>*</code>的类型：<code>N -&gt; N -&gt; N</code>），因此，由规则3，lambda表达式的类型是 <code>N - &gt; N</code> 。 于是，我们的表达式现在变成了：<code>(lambda x y . y x) (3 : N) (lambda a : N . (a * a) : N) : N -&gt; N</code></li>\n<li>所以 —— 现在我们知道，第一个lambda的参数 <code>x</code> 须是 <code>N</code> 类型，以及 <code>y</code>是 <code>N -&gt; N</code> 类型 。根据规则4我们知道，应用表达式的类型 <code>y x</code> 一定是 <code>N</code> ，然后根据规则3，表达式的类型为： <code>N -&gt; (N -&gt; N) -&gt; N</code> 。</li>\n<li>所以此处的类型 A 和 B 最后都是<code>N</code>。</li>\n</ul>\n<p>所以，现在我们得到了一个简单的类型化lambda演算。说它是简单的类型化，是因为这里对类型的处理方式很少：建立新类型的唯一途径就是通过「 <code>-&gt;</code>」 构造器。其他的类型化lambda演算包括了定义「参数化类型」（parametric types）的能力，它将类型表示为不同类型的函数。</p>\n<h2 id=\"终章，Lambda演算建模——程序即证明！\"><a class=\"header-anchor\" href=\"#终章，Lambda演算建模——程序即证明！\">※</a>终章，Lambda演算建模——程序即证明！</h2>\n<p>16 Sep 2014 | categories <a href=\"https://cgnail.github.io/categories/#academic\" title=\"academic\">academic</a> <br>\ntags <a href=\"https://cgnail.github.io/tags/#%E7%BF%BB%E8%AF%91\" title=\"翻译\">翻译</a>  <a href=\"https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97\" title=\"lambda演算\">lambda演算</a>  <a href=\"https://cgnail.github.io/tags/#function%20programming\" title=\"function programming\">function programming</a></p>\n<p>我们已经讲过直觉逻辑（intuitionistic logic）和它的模型；从无类型的Lambda演算讲到了简单类型化Lambda演算；终于，我们可以看看Lambda演算模型了。而这正是真正有趣的地方。</p>\n<p>先来考虑简单类型化Lambda演算中的类型。任何可以从下面语法生成的形式都是Lambda演算类型：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type ::= primitive | function | ( type ) </span><br><span class=\"line\">primitive ::= A | B | C | D | ... </span><br><span class=\"line\">function ::= type -&gt; type </span><br></pre></td></tr></table></figure>\n<p>这个语法中的一个陷阱是，你可以创建一个类型的表达式，而且它们是合法的类型定义，但是你无法你写出一个拥有该类型的单独的，完整的，封闭表达式。（封闭表达式是指没有自由变量的表达式。）如果一个表达式类型有类型，我们说表达式「居留」（inhabit）该类型，而该类型是一个居留类型。如果没有表达式可以居留类型，我们说这是「不可居留的」（uninhabitable） 。</p>\n<p>那么什么是居留类型和不可居留类型之间的区别？</p>\n<p>答案来自一种叫做「柯里-霍华德同构」（Curry-Howard isomorphism）的理论。这种理论提出，每个类型化的lambda演算，都有相应的直觉逻辑；类型表达式是可居留的当且仅当该类型是在对应逻辑上的定理。</p>\n<p>先看类型 <code>A -&gt; A</code>。现在，我们不把 <code>-&gt;</code> 看作函数类型构造器，而把它视作逻辑蕴涵。<code>A 蕴含 A</code> 显然是直觉主义逻辑的定理。因此，类型 <code>A -&gt; A</code> 是可居留的。</p>\n<p>再来看看 <code>A -&gt; B</code> 。这不是一个定理，除非在某个上下文中能证明它。作为一个函数类型，这表示一类函数，在不包括任何上下文的情况下，以A类型作为参数，并返回一个不同类型B。你没法做到这一点——必须有某个上下文提供B类型的值——为了访问这个上下文，必须存在某种允许函数访问它的上下文的方式：一个自由变量。这一点在逻辑上和lambda演算上是一样的：你需要某种上下文建立 <code>A-&gt;B</code> 作为一个定理（在逻辑上）或可居留的类型（在lambda演算上）。</p>\n<p>下面就容易理解些了。如果有一个封闭LC表达式，其类型是在相应的直觉逻辑中的定理，那么，该类型的表达式就是定理的一个证明。每个Beta规约则等同于逻辑中的一个推理步骤。对应于这个lambda演算的逻辑就是它的模型。从某种意义上说，lambda演算和直觉逻辑，只是同一件事的不同反映。</p>\n<p>有两种方式可以证明这个同构：一种是柯里当初采用的，组合子演算的方式；另一种则用到了所谓的「相继式演算」（Sequent calculus）。我会组合子证明的版本，所以下面我会快速的过一遍。以后，很可能下个礼拜，我会讲相继式演算的版本。</p>\n<p>让我们回忆一下什么是模型。模型是一种表示演算中的每条声明（statement）在某些具体值域上都合法的方式——所以存在具体实体和演算中的实体的对应关系，凡演算中的声明都对应真正的实体的某些声明。所以我们实际上并不需要做充分的同构；我们只需要一个从演算到逻辑的同态（homomorphism）。（同构是双向的，从演算到逻辑和逻辑到演算；而同态只从演算到逻辑。）</p>\n<p>所以我们需要做的是取任意完整的lambda演算表达式，然后将其转化为一系列合法的的直觉逻辑语句。由于直觉逻辑本身已被证明是合法的，如果我们可以把lambda演算翻译成IL，这样我们就证明了lambda演算的合法性——这意味着我们将表明，在lambda演算中的计算是合法的计算，以及lambda演算是一个完全的，合法的，有效的计算系统。</p>\n<p>我们如何从组合子（它们只是省去了变量的lambda演算的简写）得到直觉逻辑？它实际上简单得令人难以相信。</p>\n<p>直觉逻辑中的所有证明可以归结为一系列的步骤，其中的每一步都是使用了以下两个基本公理之一的推理：</p>\n<ul>\n<li><code>A implies B implies A</code></li>\n<li><code>(A implies B implies C) implies ((A implies B) implies (A implies C))</code></li>\n</ul>\n<p>让我们用箭头重写它们，让它们看起来像一个类型：<code>A -&gt; B -&gt; A</code> ；及<code>(A -&gt; B -&gt; C) -&gt; ((A -&gt; B) -&gt; (A -&gt; C))</code>。</p>\n<p>眼熟吗？不熟的话再回头看看<a href=\"https://cgnail.github.io/lambda-6\">简单类型化lambda演算</a>。这就是S和K组合子的类型。</p>\n<p>接下来的建模步骤就很明显了。lambda演算的类型对应于直觉逻辑的原子类型。函数是推理规则。每个函数可以规约为一个组合子表达式；每个组合子表达式是直觉逻辑的某个基本推理规则的实例。于是，函数就成了相应逻辑里的定理的一个构造性证明。</p>\n<p>酷吧？</p>\n<p>（任何正常人看完会说“什么？”，但，我显然不是正常人，我是一个数学怪咖。）</p>\n<h2 id=\"博客推荐：good-math-bad-math之Lambda算子简介\"><a class=\"header-anchor\" href=\"#博客推荐：good-math-bad-math之Lambda算子简介\">※</a>博客推荐：good math, bad math之Lambda算子简介</h2>\n<p><a href=\"http://goodmath.blogspot.com/\">Good math，bad math</a>是我最近发现的一个博客。作者Mark Chu-Carroll写的一系列关于计算机科学理论的文章深入浅出，通俗易懂，属于茶余饭后绝佳的消遣读物。俺一直想写点介绍lambda caculus的小文章，但看了他的“<a href=\"http://goodmath.blogspot.com/2006/05/my-favorite-calculus-lambda-part-1.html\">My Fravorite Calculus: Lambda</a>”后，就打消了这个念头。有这么好的文章，转贴就行了，自己就不用再写不入流的文章。今天先转介绍lamdba calculus的第一部分。先申明一下，俺的翻译在不影响作者原意的基础上（但愿能做到到），有时也插科打诨加点8卦。如果谁觉得文章垃圾，完全因为俺水平有限。原文绝对精彩。另外，俺数学方面的术语止于大一微积分。所以术语用错了，还请多多指正。</p>\n<p>在计算机科学尤其是是编程语言领域，我们常用一种算子：Lambda Calculus。逻辑学家也常用Lambda Calculus 来研究计算和离散数学结构的本质。其实当初<a href=\"http://en.wikipedia.org/wiki/Alonzo_Church\">Alanzo Church</a>(就是丘奇-图灵论点里的那位丘奇老大了）和<a href=\"http://en.wikipedia.org/wiki/Stephen_Cole_Kleene\">Stephen Cole Kleene</a>(就是自动机理论里Kleene Star那个Kleene了）推出这个Lambda Calculus，也是为了方便他们做逻辑方面的推理，好证明<a href=\"http://en.wikipedia.org/wiki/Entscheidungsproblem\">决定性问题</a>。当然以Church和图灵的天才，没多久他们便证明图灵机和lambda calculus具有等价的计算能力。Church提出Lambda Calculus时就怀疑他的理论能被用在其它地方。事实证明他的确高瞻远瞩。Lambda Calculus在编程的理论和实践两方面都意义深远。做理论和做函数编程的且不说。就算是玩儿脚本语言的老大们，也多半成天和lambda打交道。<a href=\"http://homepages.inf.ed.ac.uk/wadler/papers/frege/frege.pdf\">说来好玩儿</a>，计算机科学理论的发展相当诡异。常常是逻辑学家为了推进逻辑理论提出一个理论，若干年后计算机科学家出于实际需求再“重新发现”一模一样的理论。 比如说现在很多函数编程语言常用的Hindley-Milner类型系统，就是逻辑学家<a href=\"http://www-maths.swan.ac.uk/staff/jrh/\">Roger Hindley</a> 于1969年先发现，再由大名鼎鼎的牛人<a href=\"http://en.wikipedia.org/wiki/Robin_Milner\">Robin Milner</a>于1978年独立提出。说远了。Lambda Calculus本身有若干显著优点：</p>\n<ol>\n<li>它非常简单。反正比图灵机简单。</li>\n<li>它图灵完备。也就是说，图灵机能完成的计算，Lambda Calculus也能完成。</li>\n<li>它易于读写。这点很重要。简单就是力量。我们不可不记。</li>\n<li>它的语义足够强大，能让我们用它来推理。</li>\n<li>它的计算模型足够强大</li>\n<li>容易创建不同的变种，以便我们探索用不同的方式构建计算或语义时的特性</li>\n</ol>\n<p>Lambda Calculus易于读写意义重大。正是这个优点催生了许多或多或少基于lambda calculus的极为优秀的编程语言：Lisp, ML, 和Haskell都在很大程度上基于Lambda calculus开发出来。</p>\n<p>Lambda calculus建立在函数这个概念上。纯粹的lambda算子理论中，任何东西都是函数。除了函数外别无它物。不过我们可以用函数搭建出各种东西。其实我们可以从lambda calculus开始，从无到有搭建出整个数学的结构。</p>\n<p>牛皮轰轰吧？我们就来看一下lambda calculus为什么这么神奇。对任何一个算子理论来说，我们必须先定义两个东西。一是句法(syntax)，用来描述什么表达式是合法的；二是一套规则，用来规定我们怎么对表达式作合法的符号操作。</p>\n<h3 id=\"Lambda-Calculus句法\"><a class=\"header-anchor\" href=\"#Lambda-Calculus句法\">※</a>Lambda Calculus句法</h3>\n<p>Lambda calculus 只有三种表达式</p>\n<ol>\n<li>函数定义：在lambda calculus里一个函数就是一个表达式，写成lambda x . &lt;函数体&gt;。意思是“一个函数，带一个参数X，返回计算函数体后得到的结果”。这个时候我们说这个lambda表达式绑定了参数X。</li>\n<li>标识符引用（identifier reference): 一个标识符引用就是一个名字。这个名字和包括这个引用的函数定义里的参数同名。</li>\n<li>函数应用(function application): 这个更简单，把要应用的值放到函数定义的后面就行了。比如<br>\n(lambda x . plus x x) y</li>\n</ol>\n<p>这么简单的定义能干什么嗫？怎么没有多个参数嗫？这个就是数学的魅力了。我们很快会发现，多个参数可以被等价的操作（所谓的currying)来代替。而配上简单的操作后（本质操作就一个：替换），我们就得到了一门强大的编程语言，不输基于图灵机模型的Algo系列语言，比如C。</p>\n<p>欲知后事如何，且听下回分解。</p>\n<h2 id=\"lambda算子简介1-a\"><a class=\"header-anchor\" href=\"#lambda算子简介1-a\">※</a>lambda算子简介1.a</h2>\n<p>接着前两天的<a href=\"http://blog.csdn.net/g9yuayon/archive/2006/05/22/748684\">转载</a>继续写。上次说到lambda算子的函数只接受一个参数。那怎么处理多个参数呢？如果只有一个参数，那岂不是连加法都不能实现？这当然难不倒像丘齐这样的天才。于是， lo and behold,  一个我们至今在编程里常用的技巧粉墨登场：</p>\n<h3 id=\"Currying\"><a class=\"header-anchor\" href=\"#Currying\">※</a>Currying</h3>\n<p>据说Currying翻译为局部套用函数，也不知真假。喜欢吃印度美食的老大们不要激动。Currying和咖喱没有半点关系。这个技巧以逻辑学家<a href=\"http://www-history.mcs.st-andrews.ac.uk/history/Mathematicians/Curry.html\">Haskell Curry</a>的姓命名。Haskell Curry也是名动一时的人物。他和<a href=\"http://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel\">Moses Schönfinkel</a> 共创了组合逻辑（combinatory logic)，并把这们学科发扬光大。当初Curry搞出组合逻辑，主要是为了在数理逻辑里避免使用变量。后来搞函数编程的人们发现，组合逻辑是一类函数编程语言的理论基础。一些函数语言里常见的特性，比如说高阶函数合lazy evaluation, 就是用组合逻辑里的combinator实现的。当初Alanzo Church对这个理论也相当熟悉。难说lambda理论不是受了组合逻辑的影响。大牛<a href=\"http://homepages.inf.ed.ac.uk/wadler/\">Philip Wadler</a>为了纪念Curry, 把他的函数语言叫做<a href=\"http://www.haskell.org/haskellwiki/Haskell\">Haskell</a>。Haskell也是一门巨酷的函数语言，兼顾数学的优美和软件开发的实用性。连<a href=\"http://www.linspire.com/\">LInspire</a>的开发组都决定用Haskell作为系统开发的语言（但我很奇怪他们为什么放弃使用另一门酷酷的函数语言Ocaml）。说远了。</p>\n<p>解决参数限制的关键在于认识到函数也是数据（用更严格的说法，是值）。既然是数据，就可以传来传去。如果有两个参数，我们可以写一个接受第一个参数的函数，而这个函数返回的是接受第二个参数的函数。“就那么简单！我们在JavaScript里不是常用这个功能？” 嘻嘻，我们在JavaScript里的确常用这个功能。JavaScript其实是带C句法的函数语言，支持高阶函数，自然支持Currying。JavaScript的功能其实颇为强大，不然Douglas Crockford不会说<a href=\"http://www.crockford.com/javascript/javascript.html\">JavaScript是最被人误解的语言</a>。</p>\n<p>举例来说，假设我们要写一个函数，把x和y相加。最自然的写法是lambda x y . plus x y.  既然我们只能一次接受一个参数，我们可以先写一个接受 x 的函数。这个函数返回一个接受 y 的函数。这个被返回的函数把 x 和 y 相加：lambda x.(lambda y. plus x y)。简单吧？数学奇妙之处就在于我们用极为简单的砖块搭建出恢弘的宫殿。事实上，数学家们总是极力追求理论基础的简洁。他们不知疲倦地挥舞着奥卡姆剃刀，直到把自己的理论切割成东家之子：增之一分则太长，减之一分则太短。有了Currying这个工具，我们可以放心使用多参数的标记了。反正多参数的lambda不过是单参数lambda的方便用法而已，没有任何实质上的改变。</p>\n<p>（待续。累死了。什么时候才能写到让人拍案叫绝的Y Combinator啊? )</p>\n<h2 id=\"lambda算子-1-b\"><a class=\"header-anchor\" href=\"#lambda算子-1-b\">※</a>lambda算子 1.b</h2>\n<h3 id=\"自由-vs-有界标识符\"><a class=\"header-anchor\" href=\"#自由-vs-有界标识符\">※</a>自由 vs 有界标识符</h3>\n<p>标识符和变量其实是一个意思。我记得国内教材里很少用标识符这个说法。不过既然原作者用这个说法，我就跟着用了。上次说到Currying解决了如何处理多参数的问题。在讨论怎么使用lambda前，我们还要解决一个细微但重要的语法问题：封闭(closure)，或者叫完全有界(complete bounding)。这里的有界和一阶谓词逻辑里的有界没有本质区别，对一阶谓词逻辑熟悉的老大们可以放心跳过。其实有界涉及的定义很直观，我们看一个例子先。假设我们有一个函数<code>lambda x y. (lambda y. y + 2) + x + y +z</code>，<code>lambda y. y+2</code>里的y和它后面的y是不是一样的呢？显然它们是不一样的。为了处理这种区别，我们引入了有界。当一个lambda表达式被计算时，它不能处理无界的标识符。当一个标识符出现在一个lambda表达式的参数里，并且被包含在这个lambda表达式里，我们就可以说这个标识符有界。如果一个标识符没有被包含在任何一个表达式里，我们就叫它为自由变量。比如说，上面那个lambda表达式里，x 出现在<code>lambda x y .(....)</code>里，所以它是有界的变量，它的包含环境（enclosing context，用“语境”或者“上下文”怎么听怎么别扭，好像俺是《读书》的御用作者似的。😄)是整个lambda表达式。<code>lambda y. y+2</code>里的y也是有界的，但它的包含环境是<code>lambda y. y+2</code>。标识符z没有出现在包含它的表达式的参数列表里，所以是自由变量。再举几个例子：</p>\n<ol>\n<li><code>lambda x . plus x y</code>: 这个表达式里，&quot;y&quot;和&quot;plus&quot;都是自由变量，因为它们不是任何包含它们的表达式的参数。x有界，因为它被包含在plus x y里，而<code>plus x y</code>的参数有x。</li>\n<li><code>lambda x y.y x</code>: 这个表达式里，x和y都有界，因为它们是这个表达式的参数。</li>\n<li><code>lambda y . (lambda x . plus x y)</code>: 在内嵌的表达式<code>lambda x. plus x y</code>里，y和 plus 是自由变量而x是有界变量。在整个lambda表达式里，x和y都有界：x在内嵌表达式界内，而y在整个表达式界内。plus仍然自由。</li>\n</ol>\n<p>我们用&quot;free(x)&quot;来代表表达式x里所有自由变量的集合。</p>\n<p>一个lambda表达式完全合法仅当它的所有变量都有界。不过当我们考查某个复杂表达式里的子表达式且不考虑上下文时，那些子表达式可以有自由变量－其实确保正确处理那些子表达式里的自由变量非常重要。</p>\n<h3 id=\"Lambda-算子计算规则\"><a class=\"header-anchor\" href=\"#Lambda-算子计算规则\">※</a>Lambda 算子计算规则</h3>\n<p>其实真正的规则就俩：alpha和beta。Alpha规则又叫转换(conversion)规则，而beta规则又叫简化(reduction)规则。</p>\n<h3 id=\"Alpha转换-v2\"><a class=\"header-anchor\" href=\"#Alpha转换-v2\">※</a>Alpha转换</h3>\n<p>这个充满了《星际迷航》味道的规则其实就是重命名操作。它无非是说变量名不重要：给定任何一个lambda表达式，我们可以任意改变参数的名字，只要我们相应地改变这些对应这些参数的变量名字。</p>\n<p>比如说，我们有如下表达式：<br>\n<code>lambda x . if (= x 0) then 1 else x^2</code></p>\n<p>我们通过alpha规则把X改成Y（写作alpha[x/y], 和逻辑里的变量替换一个写法），于是得到：<br>\n<code>lambda y . if (= y 0) then 1 else y^2</code></p>\n<p>Alpha操作完全不影响lambda表达式的意义。不过我们后面会发现，这个操作很重要，因为它让我们能够实现诸如递归的操作。</p>\n<h3 id=\"Beta简化\"><a class=\"header-anchor\" href=\"#Beta简化\">※</a>Beta简化</h3>\n<p>Beta简化就有意思了。我们只需要这一个规则，就可以让lamdba算子实现一台计算机能做的任何计算。透过纷繁的表象，我们会发现事情的本质往往出人意料地清晰而简单。删繁为简，恰是数学魅力所在。</p>\n<p>Beta规则无非是说，应用一个函数(也就是lambda表达式。一个意思）等价于通过把函数体内有界的变量替换成应用里对应参数的实际值来替换原来的函数。听上去有些拗口（呵呵，其实原文更拗口），但当你看一个例子就知道它其实很简单：</p>\n<p>假设我们要应用一个函数：“<code>(lambda x . x + 1) 3</code>”。Beta规则说，我们可以替换整个表达式，把函数体（也就是“x+1”)里的参数对应的x替换成实际的值3。所以最后的结果是“3＋1”。</p>\n<p>再来一个稍微复杂点的例子：<br>\n<code>lambda y . (lambda x . x + y) q</code></p>\n<p>这个表达式有意思，因为应用了这个表达式后，我们可以得到另外一个表达式。也就是说，它是一个生成表达式的表达式（说到这里，玩儿动态语言的老大们可以笑了，玩儿C/C++/Java的老大们可以流口水了）。当我们对这个表达式应用Beta简化时，我们把所有对应参数y的变量替换成实际的值q。所以结果是&quot;<code>lambda x, x+q</code>&quot;。</p>\n<p>再来一个例子：<br>\n“<code>(lambda x y. x y) (lambda z . z * z) 3</code>”. 这个带两个参数的函数把第一个参数应用到第二个参数上。当我们计算它的值时，我们把第一个lambda表达式里的变量x换成<code>lambda z. z * z</code>, 再把变量y换成3，得到<code>(lambda z. z * z) 3</code>。对该结果应用Beta简化，我们得到<code>3 * 3</code>。</p>\n<p>Beta的严格定义如下：</p>\n<p><code>lambda x . B e = B[x := e] if free(e) /subset free(B[x := e]</code></p>\n<p>这个定义末尾的条件，&quot;if free(e) /subset free(B[x:=e])&quot;道出了我们需要Alpha转换的原因：仅当beta化简不会引起有界变量和自由变量的冲突时，我们可以实施Beta化简。如果一个变量“z”是&quot;e&quot;里的自由变量，那我们得保证beta化简不会让&quot;z&quot;变成有界变量。如果B里的有界变量和”e&quot;里的自由变量重名，我们必须先用Alpha转换，是的重名的变量不再重名。形式化定义不够直观，直观描述又不够简洁。还是来个例子漱漱口：</p>\n<p>给定一个表达式，<code>lambda z. lambda x. x+z</code>. 假设我们要应用这个表达式：<br>\n<code>(lambda z . (lambda x . x + z)) (x + 2)</code></p>\n<p>在实际参数&quot;(x + 2)&quot;里，x是自由变量。但x不是表达式lambda x. x+z的自由变量。也就是说，free(e) /subset free(B[ x:=e])不成立。如果我们打破Beta简化的规则，直接开始Beta简化，便会得到: <code>lambda x . x + x + 2</code></p>\n<p>&quot;x+2&quot;里自由变量，x，现在变得有界了。如果我们把结果应用到3上：<code>(lambda x. x+2+2) 3</code>，我们得到3 + 3 + 2。</p>\n<p>如果我们按正常程序办事呢？</p>\n<p>应用 alpha[x/y]: <code>lambda z . (lambda y . y+z)) (x + 2)</code><br>\n应用 beta: <code>lambda y . y + x + 2) 3</code><br>\n再次应用beta: <code>3 + x + 2</code>.</p>\n<p>“3+x+2” 和 “3+3+2” 很不一样哈！</p>\n<p>规则就这些了。我们还可以选择性地加一个所谓的Eta-化简，不过它不是必需的。我们就此跳过。我们讨论的这套系统已经是图灵完备的计算体系。那这套系统到底有什么用嗫？到底怎样才能让这套系统变得真正有用嗫？嗯，要说明这些问题，我们得先定义一些基本的函数，以便我们做算术，条件测试，递归，等等。这些会在以后的帖子里谈到。</p>\n<p>我们也还没有谈到适合lambda算子的模型（Good Math Bad Math的作者在<a href=\"http://goodmath.blogspot.com/2006/04/more-logic-models-and-why-they-matter.html\">这里</a>和<a href=\"http://goodmath.blogspot.com/2006/04/correcting-my-models-post-or-why.html\">这里</a>讨论了模型）。模型也是很重要的东西。逻辑学家用了好几年时间研究lambda算子，才搞出一个完备的模型。而且早先时候，尽管lambda算子看起来没错，为它制订模型的工作却失败了。这在当时极为引人关注。要知道，毕竟一个系统没有有效的模型就没有实际的意义。</p>\n<h2 id=\"lambda算子3-阿隆佐-丘齐-Alonzo-Church-的天才\"><a class=\"header-anchor\" href=\"#lambda算子3-阿隆佐-丘齐-Alonzo-Church-的天才\">※</a>lambda算子3:阿隆佐.丘齐(Alonzo Church)的天才</h2>\n<p><a href=\"http://blog.csdn.net/g9yuayon/archive/2006/06/12/790953.aspx\">前面</a>建立了lambda运算的基本规则，就可以用lambda算子做点有意思的东西了。开始前为方便计，我们先来点语法糖花差花差，用来命名函数。这些语法糖可以让复杂的公式好写一点。</p>\n<p>我们用&quot;let&quot; 来引入一个“全局”函数（也就是说，我们用这个函数时，不用在每个表达式里定义一次）：<br>\n<code>let squer = lambda x. x^2</code></p>\n<p>这个式子申明了一个叫&quot;square&quot;的函数，定义为 lamdba x. x^2。如果我们有一个表达式 “square 4”，上面的&quot;let&quot;意味着这个表达式和下面这个表达式一样：<code>(lambda square. square 4)(lambda x. x^2)</code>。这个&quot;let&quot;是从Common Lisp或者Scheme里借来的。Lambda算子里可没有这个东西。数学家推崇“如无必要，毋增实体”。这些关键字不入他们的法眼。不过对写惯了程序的我们来说，这些句法糖就可爱多了。</p>\n<p>我们的例子里会用到数字和算术操作符。不过记住lambda算子里根本没有数字。我们只有函数！所以我们需要发明用函数来创造数字的方法。幸好Alonzo Church是个天才。他既然发明了lambda算子，用lambda算子表征数字自然不在话下。他搞出的用于数字的函数自然就叫做丘齐数（Church Numerals)。</p>\n<p>丘齐数里，所有的数字都是两个参数的函数：</p>\n<ol>\n<li>零是 <code>lambda s z . z</code></li>\n<li>一是 <code>lambda s z . s z</code></li>\n<li>二是 <code>lambda s z . s (s z)</code></li>\n<li>对任意一个数&quot;n&quot;，它的丘齐数都是一个函数。这个函数把它的第一个参数应用到第二个参数上n次。用流行的写法，就是lambda s z . s sn z。 绕口啊绕口。做形式化的东东不幸之处就是成天和绕口令打交道。解脱这道呢？当然就是牢记牛人费因曼在<a href=\"http://www.kurzweilai.net/articles/art0504.html?printable=1\">Connection Machine工作时</a>的学习方法：问最简单的问题。“给我最简单的例子”。“怎么才能验证这是正确的？”。比如说零（lambda s z . z）吧，第一个参数是s, 应用零次就是没有，所以函数体就是孤零零的&quot;z&quot;。那数字一呢？当让就是把第一个参数，s，应用到z上一次，所以函数体就变成了&quot;s z&quot;。</li>\n</ol>\n<p>理解这个定义的方法之一时把&quot;z&quot;看作丘齐数里零的名字，而把&quot;s&quot;看后继函数（successor function)的名字。“后继函数”其实很简单，C/C<ins>里的</ins>是也。所以呢，零就是一个返回&quot;0&quot;这个值的函数；一就是把后继函数应用到零上一次的函数；二就是把后继函数应用到一上一次或者说零上两次的函数。0++ 得到 1, 1++ 等价与(0++)<ins>，而1</ins>得到2．现在把0换成z，把++换成s, 一切就清楚了。</p>\n<p>现在－－看好了。如果我们想做加法，x+y，我们需要一个带4个参数的函数。两个参数代表相加的两个数字，以及为得到结果而需要的&quot;s&quot;和&quot;z&quot;。</p>\n<p><code>let add = lambda s z x y . x s (y s z)</code></p>\n<p>看着好像有点不知所云。不过我们可以用Curry这个利器，分开&quot;s&quot; &quot;z&quot;和x, y。首先，Curry后得到的函数带两个参数，x和y（这个好比add(x, y)，符合我们对加号的理解）。其次，我们需要正规化x和y需要的s和z，让x和y共享相同的零和后继函数的绑定：</p>\n<p><code>let add = lambda x y. (lambda s z . (x s (y s z)))</code></p>\n<p>仔细观察一下，上面的式子无非是说，要把x和y相加，我们先用&quot;s&quot;和&quot;z&quot;创建丘齐数&quot;y&quot;，然后在把&quot;x&quot;应用到y上。应用时需要的&quot;s&quot;和&quot;z&quot;是&quot;y&quot;里的&quot;s&quot;和&quot;z&quot;。也就是说，我们的到的结果是一个函数，这个函数把自己加到另一个函数上。还是用例子来说明问题。比如说2+3:</p>\n<p><code>add (lambda s z. s (s z)) (lambda s z . s (s (s z))) news newz</code></p>\n<p>为了让演算变得稍微容易一点，我们先对2和3来个Alpha转换。让2用s2和z2，而3用s3和z3:</p>\n<p><code>add (lambda s2 z2 . s2 (s2 z2)) (lambda s3 z3 . s3 (s3 (s3 z3)))</code></p>\n<p>现在我们可以把&quot;add&quot;替换成它的定义了：</p>\n<p><code>(lambda x y .(lambda s z. (x s y (s z)))) (lambda s2 z2 . s2 (s2 z2)) (lambda s3 z3 . s3 (s3 (s3 z3))) </code></p>\n<p>现在可以对&quot;add&quot;用beta变换了（温馨提示：也就是把形参x和y换成对应的实参）：</p>\n<p><code>lambda s z . (lambda s2 z2 . s2 (s2 z2)) s (lambda s3 z3 . s3 (s3 (s3 z3)) s z)</code></p>\n<p>然后我们可以对3这个丘齐数做beta转换。这步操作其实是“正规化”3：把3的定义里的后继函数和零函数（还记得零是个函数吧？）替换成add的参数列表里的后继函数和零函数：</p>\n<p><code>lambda s z . (lambda s2 z2 . s2 (s2 z2)) s (s (s (s z)))</code></p>\n<p>嗯，有点眉目了。现在是真正漂亮的地方了。再来次对2的Beta变换。看看我们准备做什么：2是个带两个参数的函数：一个参数是后继函数，另一个是零函数。要把2加到3上，我们只需要用到&quot;add&quot;这个函数的后继函数。也就是说，我们把计算了3后的结果当成零函数的值！</p>\n<p><code>lambda s z . s (s (s (s (s z)))</code></p>\n<p>而这个式子，正是丘齐数5！</p>\n<p>丘齐数酷的地方是它抛弃了传统整数的概念，用函数取而代之。它把每个数对应为一个函数。而数数（counting）这个操作被对应为应用某个函数（在这里是后继函数）的次数。当然了，上面的介绍非常简单。对丘齐数感兴趣的，可以看<a href=\"http://www.informatik.uni-bonn.de/~ralf/publications/Church.pdf\">这篇文章</a>。</p>\n<p>丘齐数对编程有什么用嗫？俺还真不知道。但丘齐数（进而到丘齐编码）确实一系列基础理论中有重要应用，比如说有类型的lambda算子。不过这点重要吗？不重要吗？重要吗？不重要吗？研究研究嘛。</p>\n<h2 id=\"lamdba算子4：布尔值和选择\"><a class=\"header-anchor\" href=\"#lamdba算子4：布尔值和选择\">※</a>lamdba算子4：布尔值和选择</h2>\n<h3 id=\"Lambda算子里的布尔值和选择\"><a class=\"header-anchor\" href=\"#Lambda算子里的布尔值和选择\">※</a>Lambda算子里的布尔值和选择</h3>\n<p><a href=\"http://goodmath.blogspot.com/2006/05/booleans-and-choice-in-lambda-calculus.html\">原文</a>在这里。既然Lambda算子里有了<a href=\"http://blog.csdn.net/g9yuayon/archive/2006/08/14/1062518.aspx\">数的概念</a>，我们想进行任意的计算就只需要两件东西了：怎么表示选择，和怎么表达重复操作。我们先聊聊怎么表示布尔值（也就是非真即假的二元集合）和选择，然后再讨论重复和递归（友情预告：人见人爱的Y Combinator终于可以出场了）。</p>\n<p>我们一般把选择表示为if/then/else的表达式，和大多数编程语言的选择语句没有区别。丘齐数的基本模式无非是把一个数表达为一个函数。这个函数把它自己加到另外一个函数上。我们继续沿用这个模式，把true和false也表达为对自己的参数执行if-then-else操作的函数：<br>\n<code>let TRUE = lambda x y . x</code><br>\n<code>let FALSE = lambda x y . y</code></p>\n<p>现在我们就可以写“if-then-else”函数了（记到哈，lambda算子理论里所有东东都是函数）。这个函数的第一个参数是一个条件表达式，第二个参数是当第一个参数为真时返回的表达式，而第三个参数自然是当第一个参数为假时返回的表达式了。相当于我们的if cond then true_expr else false_expr:<br>\n<code>let IfThenElse = lambda cond true_expr false_expr . cond true_expr false_expr</code></p>\n<p>为了我们刚定义的布尔值有用，我们还得定义一些常用的逻辑操作先：<br>\n<code>let BoolAnd = lambda x y . x y FALSE</code><br>\n<code>let BoolOr = lambda x y. x TRUE y</code><br>\n<code>let BoolNot = lambda x . x FALSE TRUE</code></p>\n<p>上面定义了常用的“与”，“或”，和“非”操作。我们可以稍微考查一下它们的机制。</p>\n<p><code>BoolAnd TRUE FALSE （也就是 true &amp;&amp; false)</code>：</p>\n<p>我们把TRUE和FALSE替换为它们的定义:  <code>BoolAnd (lambda x y . x) (lambda x y . y)</code><br>\n执行Alpha 替换避免混淆变量名：<code>BoolAnd （lambda xt yt . xt) (lambda xf yf . yf)</code>然后把BoolAnd替换为它的定义：<code>（lambda x  y . x y FALSE）(lambda xt yt . xt) (lambda xf yf . yf)</code>执行Beta替换：<code>(lambda xt yt . xt) (lambda xf yf . yf) FALSE</code>呵呵，再Beta一把：<code>(lambda xf yf . yf)</code>。</p>\n<p>最后的结果<code>lambda xf yf</code> . yf就是FALSE的定义。也就是说， <code>BoolAnd TRUE FALSE = FALSE</code>。神奇吧？看起来只是简单的替换：变量替换，参数替换，但最后的结果确意义重大。这让我想起当年第一次读<a href=\"http://www.amazon.com/exec/obidos/tg/detail/-/0465026567?v=glance\">GEB</a>时不由自主地感叹，看似简单的句法层面的操作竟然能得出迷幻般的结果。</p>\n<p>我们再来看看 false &amp;&amp; true, 也就是 <code>BoolAnd FALSE TRUE</code>。“噫，那不是和我们刚推演过<code>的BoolAnd TRUE FALSE</code>一样么！”。眼尖的老大们可能要问。嗯，我们知道布尔逻辑里的操作是服从交换率的，所以 a &amp;&amp; b 等于 b &amp;&amp; a。可惜我们在用lambda算子定义布尔操作，是不是服从交换率，需要我们证明。如果<code>BoolAnd FALSE TRUE</code>的结果是FALSE，我们也就证明了BoolAnd符合交换率：定义替换：<code>BoolAnd (lambda x y . y) (lambda x y .x)</code><br>\nAlpha替换: <code>BoolAnd (lambda xf yf . yf) (lambda xt yt . xt)</code><br>\n替换BoolAnd的定义: <code>(lambda x y .x y FALSE) (lambda xf yf . yf) (lambda xt yt . xt)</code><br>\nBeta替换: <code>(lambda xf yf . yf) (lambda xt yt . xt) FALSE</code><br>\n再来Beta替换: <code>lambda xt yt. xt</code>, 也就是FALSE<br>\n所以说， <code>BoolAnd FALSE TRUE = FALSE</code></p>\n<p>最后，我们来看看BoolAnd TRUE TRUE:<br>\n定义替换：<code>BoolAnd (lambda x y . x) (lambda x y . x)</code><br>\nAlpha替换: <code>BoolAnd (lambda xa ya . xa) (lambda xb yb . xb)</code><br>\n替换BoolAnd的定义: <code>(lambda x y . x y FALSE) (lambda xa ya . xa) (lambda xb yb . xb)</code><br>\nBeta替换: <code>(lambda xa ya . xa) (lambda xb yb . xb) FALSE</code><br>\n再次Beta替换: <code>(lambda xb yb .xb)</code>，这个正是TRUE的定义所以我们得到<code>BoolAnd TRUE TRUE = TRUE</code></p>\n<h2 id=\"Lambda算子5b：How-of-Y\"><a class=\"header-anchor\" href=\"#Lambda算子5b：How-of-Y\">※</a>Lambda算子5b：How of Y</h2>\n<p>其实是 <a href=\"WhyOfY.pdf\">这篇文章</a>的意译。有些东西省了。添了点私货。就有了下面的帖子。虽然Y相当神奇。对它的推导也不完全是天外飞仙般无迹可寻。基本上我们为了解决让没有名字的函数能自我引用，一步一步抽象出了Y。所以知道Y的推导过程对我们程序员还是很有意义的：毕竟编程的过程也是抽象的过程。看看当年的老大们怎么从纷繁的表象里抽象出一般规律，对我们日后的思考应该大有好处。为了老大们能够试验，我就用JavaScript了。整个推导的过程非常像编程时的重构。我们提出一个粗略的解决方案，然后仔细观察，找出可以抽象的地方，进行抽象。得到一个更普适的结果后，继续重复重构的步骤，直到得到最优解。估计看这篇帖子的人都知道怎么玩儿小小JavaScript吧？再说有个浏览器就有了测试环境。废话少说，看代码。我们还是以阶乘函数为例。先看通常的写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fact</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n * <span class=\"title function_\">fact</span>(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的JavaScript函数定义内部调用自己。这种调用可行的前提是我们用函数名指代函数定义。也就是说， fact这个名字绑定的函数定义就是上面的函数体。如果我们不能通过名字来调用函数怎么办呢（就跟lambda算子一样）？也许有老大会问：为什么增加这个限制呢？不是自虐么？理由很简单：理论需要探求事物本质。记得奥卡姆剃刀吧？如无必要，毋增实体。函数名到底是必需元素，还是句法糖？这种研究方法也有实际的意义：再复杂的系统也是在简单但完备的基础上搭建起来的。强大的编程工具，总是基于于层层叠加的抽象，而最低级的抽象层总是非常简单。简单意味着透彻，简单意味着健壮。简单意味着灵活。简单意味着经济。问题是，到底简单到什么地步？怎么保证系统不至于简单到一无所用的地步？这和逻辑学家建立系统时总是要证明系统的正确性和完备性一个道理。而找到了Y，我们也就明白了，原来函数名绑定并非本质。</p>\n<p>嗯，继续。函数 fact是递归的基本形式。既然我们不能直接在函数体内通过函数名调用另一个函数，我们至少可以把想调用的函数通过参数传进去。</p>\n","_path":"20240428/lyan-suan/","_link":"https://yaoqs.github.io/20240428/lyan-suan/","_id":"clzpq9hw5006csgere71f6hcw"}}