{"type":"getPostByPath","data":{"title":"无耻的驱动加载法(ZT)","date":"2024-03-24T12:43:58.000Z","description":"","categories":[],"tags":[],"content":"<p>转载自 <a href=\"http://www.blogjava.net/baicker/archive/2007/12/29/171537.html\">无耻的驱动加载法(ZT)</a></p>\n<p>无耻的驱动加载法   from : http : <a href=\"//www.debugman.com/read.php?tid=614\">//www.debugman.com/read.php?tid=614</a></p>\n<p>方法一： 替换win32k . sys</p>\n<p>在 2k3 的系统下ZwSetSystemInformation禁止了用户模式下加载驱动，只允许SMSS . exe加载win32k . sys。于是我们可以利用一下这个特点：<br>\n1.  注入SMSS . EXE<br>\n2.  打开SeLoadDriverPrivilege权限<br>\n3.  把原始的win32k . sys改名<br>\n4.  复制我们的驱动到\\systemroot\\system32下<br>\n5.  在SMSS . EXE中加载\\SystemRoot\\System32\\win32k . sys<br>\n6.  把\\SystemRoot\\System32\\win32k . sys改名<br>\n7.  把原始的win32k . sys文件改名改回去`</p>\n<p>方法二： 利用第三方驱动程序的漏洞</p>\n<p>这类驱动应该挺多的，我们可以选择一些装机量大的驱动来进行此项工作，如某某著名的杀毒软件即存在本地权限提升漏洞。。。获得了ring0权限再用ZwSetSystemInformation加载就万事大吉了</p>\n<p>方法三： 感染随系统启动的驱动程序</p>\n<p>此法类似于病毒感染，但需要等到下次系统重启才能拿到控制权，需要一些PE知识，这个我就不多说了。</p>\n<p>这里顺便再说说通过ZwSetSystemInformation其实也是可以建立Device的，由于ZwSetSystemInformation加载驱动时传给DriverEntry的DriverObject指针是错误的，因此我们不能用它来创建Device,  但我们可以自己分配一个DriverObject来创建，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTSTATUS       <span class=\"title function_\">DriverEntry</span>  <span class=\"params\">(IN PDRIVER_OBJECT DriverObject , IN PUNICODE_STRING RegistryPath)</span>       &#123;</span><br><span class=\"line\">    NTSTATUS        ntStatus  =  STATUS_SUCCESS ;</span><br><span class=\"line\">    UNICODE_STRING  ntUnicodeString ;</span><br><span class=\"line\">    UNICODE_STRING  ntWin32NameString ;</span><br><span class=\"line\">    PDEVICE_OBJECT  deviceObject  =  <span class=\"literal\">NULL</span> ;</span><br><span class=\"line\">    ULONG          i ; </span><br><span class=\"line\">    DriverObject  =  ExAllocatePoolWithTag ( NonPagedPool ,  <span class=\"keyword\">sizeof</span> ( DRIVER_OBJECT ),  <span class=\"string\">&#x27;clAS&#x27;</span> );   </span><br><span class=\"line\">    <span class=\"comment\">// 分配DriverObject </span></span><br><span class=\"line\">    RtlZeroMemory ( DriverObject ,  <span class=\"keyword\">sizeof</span> ( DRIVER_OBJECT )); RtlInitUnicodeString ( &amp; ntUnicodeString ,  NT_DEVICE_NAME  ); </span><br><span class=\"line\">    ntStatus  =  IoCreateDevice (    </span><br><span class=\"line\">        DriverObject ,    </span><br><span class=\"line\">        <span class=\"number\">0</span> ,               </span><br><span class=\"line\">        &amp; ntUnicodeString ,    </span><br><span class=\"line\">        <span class=\"number\">0x8800</span> ,                                      <span class=\"comment\">//设备类型必须为自定义的 </span></span><br><span class=\"line\">    FILE_DEVICE_SECURE_OPEN ,    </span><br><span class=\"line\">    TRUE ,               </span><br><span class=\"line\">    &amp; deviceObject  ); </span><br><span class=\"line\">    <span class=\"keyword\">if</span>  ( ! NT_SUCCESS (  ntStatus  ) )           &#123;    </span><br><span class=\"line\">        DbgPrint ( <span class=\"string\">&quot;Couldn&#x27;t create the device object\\n&quot;</span> );    </span><br><span class=\"line\">        <span class=\"keyword\">return</span>  ntStatus ;           &#125; </span><br><span class=\"line\">        <span class=\"comment\">// 注意，需要我们自己来清除INITIALIZING标志，否则设置不能打开</span></span><br><span class=\"line\">        ClearFlag (  deviceObject -&gt; Flags ,  DO_DEVICE_INITIALIZING  );                 </span><br><span class=\"line\">        DriverObject -&gt; MajorFunction [ IRP_MJ_CREATE ] =  CreateClose ;</span><br><span class=\"line\">        DriverObject -&gt; MajorFunction [ IRP_MJ_CLOSE ] =  CreateClose ; </span><br><span class=\"line\">        <span class=\"comment\">// 注意，必须要给IRP_MJ_CLEANUP分派一个DispathRoutine, 否则在设备关闭的时候就会挂</span></span><br><span class=\"line\">        DriverObject -&gt; MajorFunction [ IRP_MJ_CLEANUP ] =  CreateClose ; </span><br><span class=\"line\">        DriverObject -&gt; MajorFunction [ IRP_MJ_DEVICE_CONTROL ] =  DeviceControl ; </span><br><span class=\"line\">        <span class=\"comment\">// 注意，必须是Global符号连接, 否则程序退出后连接会消失</span></span><br><span class=\"line\">        RtlInitUnicodeString ( &amp; ntWin32NameString ,  L <span class=\"string\">&quot;\\\\DosDevices\\\\Global\\\\RkrTest&quot;</span>  ); </span><br><span class=\"line\">        ntStatus  =  IoCreateSymbolicLink (                               </span><br><span class=\"line\">            &amp; ntWin32NameString , &amp; ntUnicodeString  ); </span><br><span class=\"line\">            <span class=\"keyword\">if</span>  ( ! NT_SUCCESS (  ntStatus  ) )           &#123;    </span><br><span class=\"line\">                DbgPrint (( <span class=\"string\">&quot;Couldn&#x27;t create symbolic link\\n&quot;</span> ));    </span><br><span class=\"line\">                IoDeleteDevice (  deviceObject  );           </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                <span class=\"keyword\">return</span>  ntStatus ;       </span><br><span class=\"line\">                &#125; </span><br></pre></td></tr></table></figure>\n<p>如果你高兴的话在分配空间的时候分配多一点，把OBJECT_HEADER也算上，这样可以避免某些软件扫描DriverObject的对象头时挂掉 . 相应的用CreateFile时打开时应像这样指定“\\\\ . \\Global\\SymbolLink”  还有哪些无耻的办法大家可以讨论一下  `</p>\n","_path":"20240324/wu-chi-de-qu-dong-jia-zai-fa-zt/","_link":"https://yaoqs.github.io/20240324/wu-chi-de-qu-dong-jia-zai-fa-zt/","_id":"clzpq9hxr008tsger8a0thbts"}}