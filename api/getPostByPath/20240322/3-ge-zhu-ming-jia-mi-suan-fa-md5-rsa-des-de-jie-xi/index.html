{"type":"getPostByPath","data":{"title":"3个著名加密算法(MD5、RSA、DES)的解析","date":"2024-03-22T03:08:25.000Z","description":"","categories":[],"tags":[],"content":"<p>转载自 <a href=\"https://www.iplaysoft.com/encrypt-arithmetic.html\">3个著名加密算法(MD5、RSA、DES)的解析</a></p>\n<p>MD5的全称是Message-Digest Algorithm 5，在90年代初由MIT的计算机科学实验室和RSA Data Security Inc发明，经MD2、MD3和MD4发展而来。<br>\nMD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。</p>\n<p>MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。<br>\nMD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的， 用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并不“知道”用户的密码是什么。</p>\n<p>RSA是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。算法的名字以发明者的名字命名：Ron Rivest, Adi Shamir 和Leonard Adleman。但RSA的安全性一直未能得到理论上的证明。它经历了各种攻击，至今未被完全攻破。</p>\n<p>DES算法<br>\n美国国家标准局1973年开始研究除国防部外的其它部门的计算机系统的数据加密标准，于1973年5月15日和1974年8月27日先后两次向公众发出了征求加密算法的公告。 1977年1月，美国政府颁布：采纳IBM公司设计的方案作为非机密数据的正式数据加密标准（DES?Data Encryption Standard）。</p>\n<p><strong>1.加密算法之MD5算法</strong></p>\n<p>在一些初始化处理后，MD5以512位分组来处理输入文本，每一分组又划分为16个32位子分组。算法的输出由四个32位分组组成，将它们级联形成一个128位散列值。<br>\n首先填充消息使其长度恰好为一个比512位的倍数仅小64位的数。填充方法是附一个1在消息后面，后接所要求的多个0，然后在其后附上64位的消息长度（填充前）。这两步的作用是使消息长度恰好是512位的整数倍（算法的其余部分要求如此），同时确保不同的消息在填充后不相同。<br>\n四个32位变量初始化为：<br>\nA=0x01234567<br>\nB=0x89abcdef<br>\nC=0xfedcba98<br>\nD=0x76543210<br>\n它们称为链接变量（chaining variable）<br>\n接着进行算法的主循环，循环的次数是消息中512位消息分组的数目。<br>\n将上面四个变量复制到别外的变量中：A到a，B到b，C到c，D到d。<br>\n主循环有四轮（MD4只有三轮），每轮很相拟。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。<br>\n以一下是每次操作中用到的四个非线性函数（每轮一个）。<br>\nF(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z)<br>\nG(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z))<br>\nH(X,Y,Z)=X<sup>Y</sup>Z<br>\nI(X,Y,Z)=Y^(X|(~Z))<br>\n(&amp;是与,|是或,~是非,^是异或)<br>\n这些函数是这样设计的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。<br>\n函数F是按逐位方式操作：如果X，那么Y，否则Z。函数H是逐位奇偶操作符。<br>\n设Mj表示消息的第j个子分组（从0到15），&lt;&lt;&lt; s表示循环左移s位，则四种操作为：<br>\nFF(a,b,c,d,Mj,s,ti)表示a=b+((a+(F(b,c,d)+Mj+ti)&lt;&lt;&lt; s)<br>\nGG(a,b,c,d,Mj,s,ti)表示a=b+((a+(G(b,c,d)+Mj+ti)&lt;&lt;&lt; s)<br>\nHH(a,b,c,d,Mj,s,ti)表示a=b+((a+(H(b,c,d)+Mj+ti)&lt;&lt;&lt; s)<br>\nII(a,b,c,d,Mj,s,ti)表示a=b+((a+(I(b,c,d)+Mj+ti)&lt;&lt;&lt; s)<br>\n这四轮（64步）是：<br>\n第一轮<br>\nFF(a,b,c,d,M0,7,0xd76aa478)<br>\nFF(d,a,b,c,M1,12,0xe8c7b756)<br>\nFF(c,d,a,b,M2,17,0x242070db)<br>\nFF(b,c,d,a,M3,22,0xc1bdceee)<br>\nFF(a,b,c,d,M4,7,0xf57c0faf)<br>\nFF(d,a,b,c,M5,12,0x4787c62a)<br>\nFF(c,d,a,b,M6,17,0xa8304613)<br>\nFF(b,c,d,a,M7,22,0xfd469501)<br>\nFF(a,b,c,d,M8,7,0x698098d8)<br>\nFF(d,a,b,c,M9,12,0x8b44f7af)<br>\nFF(c,d,a,b,M10,17,0xffff5bb1)<br>\nFF(b,c,d,a,M11,22,0x895cd7be)<br>\nFF(a,b,c,d,M12,7,0x6b901122)<br>\nFF(d,a,b,c,M13,12,0xfd987193)<br>\nFF(c,d,a,b,M14,17,0xa679438e)<br>\nFF(b,c,d,a,M15,22,0x49b40821)<br>\n第二轮<br>\nGG(a,b,c,d,M1,5,0xf61e2562)<br>\nGG(d,a,b,c,M6,9,0xc040b340)<br>\nGG(c,d,a,b,M11,14,0x265e5a51)<br>\nGG(b,c,d,a,M0,20,0xe9b6c7aa)<br>\nGG(a,b,c,d,M5,5,0xd62f105d)<br>\nGG(d,a,b,c,M10,9,0x02441453)<br>\nGG(c,d,a,b,M15,14,0xd8a1e681)<br>\nGG(b,c,d,a,M4,20,0xe7d3fbc8)<br>\nGG(a,b,c,d,M9,5,0x21e1cde6)<br>\nGG(d,a,b,c,M14,9,0xc33707d6)<br>\nGG(c,d,a,b,M3,14,0xf4d50d87)<br>\nGG(b,c,d,a,M8,20,0x455a14ed)<br>\nGG(a,b,c,d,M13,5,0xa9e3e905)<br>\nGG(d,a,b,c,M2,9,0xfcefa3f8)<br>\nGG(c,d,a,b,M7,14,0x676f02d9)<br>\nGG(b,c,d,a,M12,20,0x8d2a4c8a)<br>\n第三轮<br>\nHH(a,b,c,d,M5,4,0xfffa3942)<br>\nHH(d,a,b,c,M8,11,0x8771f681)<br>\nHH(c,d,a,b,M11,16,0x6d9d6122)<br>\nHH(b,c,d,a,M14,23,0xfde5380c)<br>\nHH(a,b,c,d,M1,4,0xa4beea44)<br>\nHH(d,a,b,c,M4,11,0x4bdecfa9)<br>\nHH(c,d,a,b,M7,16,0xf6bb4b60)<br>\nHH(b,c,d,a,M10,23,0xbebfbc70)<br>\nHH(a,b,c,d,M13,4,0x289b7ec6)<br>\nHH(d,a,b,c,M0,11,0xeaa127fa)<br>\nHH(c,d,a,b,M3,16,0xd4ef3085)<br>\nHH(b,c,d,a,M6,23,0x04881d05)<br>\nHH(a,b,c,d,M9,4,0xd9d4d039)<br>\nHH(d,a,b,c,M12,11,0xe6db99e5)<br>\nHH(c,d,a,b,M15,16,0x1fa27cf8)<br>\nHH(b,c,d,a,M2,23,0xc4ac5665)<br>\n第四轮<br>\nII(a,b,c,d,M0,6,0xf4292244)<br>\nII(d,a,b,c,M7,10,0x432aff97)<br>\nII(c,d,a,b,M14,15,0xab9423a7)<br>\nII(b,c,d,a,M5,21,0xfc93a039)<br>\nII(a,b,c,d,M12,6,0x655b59c3)<br>\nII(d,a,b,c,M3,10,0x8f0ccc92)<br>\nII(c,d,a,b,M10,15,0xffeff47d)<br>\nII(b,c,d,a,M1,21,0x85845dd1)<br>\nII(a,b,c,d,M8,6,0x6fa87e4f)<br>\nII(d,a,b,c,M15,10,0xfe2ce6e0)<br>\nII(c,d,a,b,M6,15,0xa3014314)<br>\nII(b,c,d,a,M13,21,0x4e0811a1)<br>\nII(a,b,c,d,M4,6,0xf7537e82)<br>\nII(d,a,b,c,M11,10,0xbd3af235)<br>\nII(c,d,a,b,M2,15,0x2ad7d2bb)<br>\nII(b,c,d,a,M9,21,0xeb86d391)<br>\n常数ti可以如下选择：<br>\n在第i步中，ti是4294967296*abs(sin(i))的整数部分,i的单位是弧度。<br>\n(2的32次方)<br>\n所有这些完成之后，将A，B，C，D分别加上a，b，c，d。然后用下一分组数据继续运行算法，最后的输出是A，B，C和D的级联。<br>\nMD5的安全性</p>\n<p>MD5相对MD4所作的改进：<br>\n1.增加了第四轮.<br>\n2.每一步均有唯一的加法常数.<br>\n3.为减弱第二轮中函数G的对称性从(X&amp;Y)|(X&amp;Z)|(Y&amp;Z)变为(X&amp;Z)|(Y&amp;(~Z))<br>\n4.第一步加上了上一步的结果,这将引起更快的雪崩效应.<br>\n5.改变了第二轮和第三轮中访问消息子分组的次序,使其更不相似.<br>\n6.近似优化了每一轮中的循环左移位移量以实现更快的雪崩效应.各轮的位移量互不相同.</p>\n<p><strong>2.加密算法之RSA算法</strong></p>\n<p>它是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。算法的名字以发明者的名字命名：Ron Rivest, Adi Shamir 和Leonard Adleman。但RSA的安全性一直未能得到理论上的证明。它经历了各种攻击，至今未被完全攻破。</p>\n<p>一、RSA算法 :</p>\n<p>首先, 找出三个数, p, q, r,<br>\n其中 p, q 是两个相异的质数, r 是与 (p-1)(q-1) 互质的数…<br>\np, q, r 这三个数便是 private key</p>\n<p>接著, 找出 m, 使得 rm == 1 mod (p-1)(q-1)…<br>\n这个 m 一定存在, 因为 r 与 (p-1)(q-1) 互质, 用辗转相除法就可以得到了…<br>\n再来, 计算 n = pq…<br>\nm, n 这两个数便是 public key</p>\n<p>编码过程是, 若资料为 a, 将其看成是一个大整数, 假设 a &lt; n…<br>\n如果 a &gt;= n 的话, 就将 a 表成 s 进位 (s &lt;= n, 通常取 s = 2^t),<br>\n则每一位数均小於 n, 然後分段编码…<br>\n接下来, 计算 b == a^m mod n, (0 &lt;= b &lt; n),<br>\nb 就是编码後的资料…</p>\n<p>解码的过程是, 计算 c == b^r mod pq (0 &lt;= c &lt; pq),<br>\n於是乎, 解码完毕… 等会会证明 c 和 a 其实是相等的</p>\n<p>如果第三者进行窃听时, 他会得到几个数: m, n(=pq), b…<br>\n他如果要解码的话, 必须想办法得到 r…<br>\n所以, 他必须先对 n 作质因数分解…<br>\n要防止他分解, 最有效的方法是找两个非常的大质数 p, q,<br>\n使第三者作因数分解时发生困难…</p>\n<p>&lt;定理&gt;<br>\n若 p, q 是相异质数, rm == 1 mod (p-1)(q-1),<br>\na 是任意一个正整数, b == a^m mod pq, c == b^r mod pq,<br>\n则 c == a mod pq</p>\n<p>证明的过程, 会用到费马小定理, 叙述如下:<br>\nm 是任一质数, n 是任一整数, 则 n^m == n mod m<br>\n(换另一句话说, 如果 n 和 m 互质, 则 n^(m-1) == 1 mod m)<br>\n运用一些基本的群论的知识, 就可以很容易地证出费马小定理的…</p>\n<p>&lt;证明&gt;<br>\n因为 rm == 1 mod (p-1)(q-1), 所以 rm = k(p-1)(q-1) + 1, 其中 k 是整数<br>\n因为在 modulo 中是 preserve 乘法的<br>\n(x == y mod z and u == v mod z =&gt; xu == yv mod z),<br>\n所以, c == b^r == (a<sup>m)</sup>r == a^(rm) == a^(k(p-1)(q-1)+1) mod pq</p>\n<p>1. 如果 a 不是 p 的倍数, 也不是 q 的倍数时,<br>\n则 a^(p-1) == 1 mod p (费马小定理) =&gt; a^(k(p-1)(q-1)) == 1 mod p<br>\na^(q-1) == 1 mod q (费马小定理) =&gt; a^(k(p-1)(q-1)) == 1 mod q<br>\n所以 p, q 均能整除 a^(k(p-1)(q-1)) - 1 =&gt; pq | a^(k(p-1)(q-1)) - 1<br>\n即 a^(k(p-1)(q-1)) == 1 mod pq<br>\n=&gt; c == a^(k(p-1)(q-1)+1) == a mod pq</p>\n<p>2. 如果 a 是 p 的倍数, 但不是 q 的倍数时,<br>\n则 a^(q-1) == 1 mod q (费马小定理)<br>\n=&gt; a^(k(p-1)(q-1)) == 1 mod q<br>\n=&gt; c == a^(k(p-1)(q-1)+1) == a mod q<br>\n=&gt; q | c - a<br>\n因 p | a<br>\n=&gt; c == a^(k(p-1)(q-1)+1) == 0 mod p<br>\n=&gt; p | c - a<br>\n所以, pq | c - a =&gt; c == a mod pq</p>\n<p>3. 如果 a 是 q 的倍数, 但不是 p 的倍数时, 证明同上</p>\n<p>4. 如果 a 同时是 p 和 q 的倍数时,<br>\n则 pq | a<br>\n=&gt; c == a^(k(p-1)(q-1)+1) == 0 mod pq<br>\n=&gt; pq | c - a<br>\n=&gt; c == a mod pq<br>\nQ.E.D.</p>\n<p>这个定理说明 a 经过编码为 b 再经过解码为 c 时, a == c mod n (n = pq)…<br>\n但我们在做编码解码时, 限制 0 &lt;= a &lt; n, 0 &lt;= c &lt; n,<br>\n所以这就是说 a 等於 c, 所以这个过程确实能做到编码解码的功能…</p>\n<p>二、RSA 的安全性</p>\n<p>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解 RSA就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。目前， RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显然的攻击方法。现在，人们已能分解多个十进制位的大素数。因此，模数n 必须选大一些，因具体适用情况而定。</p>\n<p>三、RSA的速度</p>\n<p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。</p>\n<p>四、RSA的选择密文攻击</p>\n<p>RSA在选择密文攻击面前很脆弱。一般攻击者是将某一信息作一下伪装( Blind)，让拥有私钥的实体签署。然后，经过计算就可得到它所想要的信息。实际上，攻击利用的都是同一个弱点，即存在这样一个事实：乘幂保留了输入的乘法结构：</p>\n<p>( XM )^d = X^d *M^d mod n</p>\n<p>前面已经提到，这个固有的问题来自于公钥密码系统的最有用的特征–每个人都能使用公钥。但从算法上无法解决这一问题，主要措施有两条：一条是采用好的公钥协议，保证工作过程中实体不对其他实体任意产生的信息解密，不对自己一无所知的信息签名；另一条是决不对陌生人送来的随机文档签名，签名时首先使用One-Way HashFunction 对文档作HASH处理，或同时使用不同的签名算法。在中提到了几种不同类型的攻击方法。</p>\n<p>五、RSA的公共模数攻击</p>\n<p>若系统中共有一个模数，只是不同的人拥有不同的e和d，系统将是危险的。最普遍的情况是同一信息用不同的公钥加密，这些公钥共模而且互质，那末该信息无需私钥就可得到恢复。设P为信息明文，两个加密密钥为e1和e2，公共模数是n，则：</p>\n<p>C1 = P^e1 mod n</p>\n<p>C2 = P^e2 mod n</p>\n<p>密码分析者知道n、e1、e2、C1和C2，就能得到P。</p>\n<p>因为e1和e2互质，故用Euclidean算法能找到r和s，满足：</p>\n<p>r * e1 + s * e2 = 1</p>\n<p>假设r为负数，需再用Euclidean算法计算C1^(-1)，则</p>\n<p>( C1^(-1) )^(-r) * C2^s = P mod n</p>\n<p>另外，还有其它几种利用公共模数攻击的方法。总之，如果知道给定模数的一对e和d，一是有利于攻击者分解模数，一是有利于攻击者计算出其它成对的e’和d’，而无需分解模数。解决办法只有一个，那就是不要共享模数n。</p>\n<p>RSA的小指数攻击。 有一种提高 RSA速度的建议是使公钥e取较小的值，这样会使加密变得易于实现，速度有<br>\n所提高。但这样作是不安全的，对付办法就是e和d都取较大的值。</p>\n<p>RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价。即RSA的重大缺陷是无法从理论上把握它的保密性能如何，而且密码学界多数人士倾向于因子分解不是NPC问题。 RSA的缺点主要有：A)产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。B)分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。目前，SET( Secure Electronic Transaction )协议中要求CA采用比特长的密钥，其他实体使用比特的密钥。</p>\n<p><strong>3.加密算法之DES算法</strong></p>\n<p>一、DES算法</p>\n<p>美国国家标准局1973年开始研究除国防部外的其它部门的计算机系统的数据加密标准，于1973年5月15日和1974年8月27日先后两次向公众发出了征求加密算法的公告。加密算法要达到的目的（通常称为DES 密码算法要求）主要为以下四点： ☆提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改；</p>\n<p>☆具有相当高的复杂性，使得破译的开销超过可能获得的利益，同时又要便于理解和掌握；</p>\n<p>☆DES密码体制的安全性应该不依赖于算法的保密，其安全性仅以加密密钥的保密为基础；</p>\n<p>☆实现经济，运行有效，并且适用于多种完全不同的应用。</p>\n<p>1977年1月，美国政府颁布：采纳IBM公司设计的方案作为非机密数据的正式数据加密标准（DES?Data Encryption Standard）。</p>\n<p>目前在国内，随着三金工程尤其是金卡工程的启动，DES算法在POS、ATM、磁卡及智能卡（IC卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的PIN的加密传输，IC卡与POS间的双向认证、金融交易数据包的MAC校验等，均用到DES算法。<br>\n　　DES算法的入口参数有三个：Key、Data、Mode。其中Key为8个字节共64位，是DES算法的工作密钥；Data也为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式，有两种：加密或解密。<br>\n　　DES算法是这样工作的：如Mode为加密，则用Key 去把数据Data进行加密， 生成Data的密码形式（64位）作为DES的输出结果；如Mode为解密，则用Key去把密码形式的数据Data解密，还原为Data的明码形式（64位）作为DES的输出结果。在通信网络的两端，双方约定一致的Key，在通信的源点用Key对核心数据进行DES加密，然后以密码形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的Key对密码数据进行解密，便再现了明码形式的核心数据。这样，便保证了核心数据（如PIN、MAC等）在公共通信网中传输的安全性和可靠性。<br>\n　　通过定期在通信网络的源端和目的端同时改用新的Key，便能更进一步提高数据的保密性，这正是现在金融交易网络的流行做法。<br>\n　　DES算法详述<br>\n　　DES算法把64位的明文输入块变为64位的密文输出块，它所使用的密钥也是64位，整个算法的主流程图如下：<br>\n其功能是把输入的64位数据块按位重新组合，并把输出分为L0、R0两部分，每部分各长32位，其置换规则见下表：<br>\n58,50,12,34,26,18,10,2,60,52,44,36,28,20,12,4,<br>\n　　62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,<br>\n　　57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,<br>\n　　61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,<br>\n　　即将输入的第58位换到第一位，第50位换到第2位，…，依此类推，最后一位是原来的第7位。L0、R0则是换位输出后的两部分，L0是输出的左32位，R0 是右32位，例：设置换前的输入值为D1D2D3…D64，则经过初始置换后的结果为：L0=D58D50…D8；R0=D57D49…D7。<br>\n　　经过16次迭代运算后。得到L16、R16，将此作为输入，进行逆置换，即得到密文输出。逆置换正好是初始置的逆运算，例如，第1位经过初始置换后，处于第40位，而通过逆置换，又将第40位换回到第1位，其逆置换规则如下表所示：<br>\n　　40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,<br>\n　　38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,<br>\n　　36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,<br>\n　　34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25,<br>\n放大换位表<br>\n　　32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10,11,<br>\n　　12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,<br>\n　　22,23,24,25,24,25,26,27,28,29,28,29,30,31,32, 1,<br>\n单纯换位表<br>\n　　16,7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10,<br>\n　　2,8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25,<br>\n　　在f(Ri,Ki)算法描述图中，S1,S2…S8为选择函数，其功能是把6bit数据变为4bit数据。下面给出选择函数Si(i=1,2…的功能表：<br>\n选择函数Si<br>\nS1:<br>\n　　14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,<br>\n　　0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,<br>\n　　4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,<br>\n　　15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,<br>\nS2:<br>\n　　15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,<br>\n　　3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,<br>\n　　0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,<br>\n　　13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,<br>\nS3:<br>\n　　10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,<br>\n　　13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,<br>\n　　13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,<br>\n　　1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,<br>\nS4:<br>\n　　7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,<br>\n　　13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,<br>\n　　10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,<br>\n　　3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,<br>\nS5:<br>\n　　2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,<br>\n　　14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,<br>\n　　4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,<br>\n　　11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,<br>\nS6:<br>\n　　12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,<br>\n　　10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,<br>\n　　9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,<br>\n　　4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,<br>\nS7:<br>\n　　4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,<br>\n　　13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,<br>\n　　1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,<br>\n　　6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,<br>\nS8:<br>\n　　13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,<br>\n　　1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,<br>\n　　7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,<br>\n　　2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,<br>\n在此以S1为例说明其功能，我们可以看到：在S1中，共有4行数据，命名为0，1、2、3行；每行有16列，命名为0、1、2、3，…，14、15列。<br>\n　　现设输入为： D＝D1D2D3D4D5D6<br>\n令：列＝D2D3D4D5<br>\n　　行＝D1D6<br>\n　　然后在S1表中查得对应的数，以4位二进制表示，此即为选择函数S1的输出。下面给出子密钥Ki(48bit)的生成算法<br>\n　　从子密钥Ki的生成算法描述图中我们可以看到：初始Key值为64位，但DES算法规定，其中第8、16、…64位是奇偶校验位，不参与DES运算。故Key 实际可用位数便只有56位。即：经过缩小选择换位表1的变换后，Key 的位数由64 位变成了56位，此56位分为C0、D0两部分，各28位，然后分别进行第1次循环左移，得到C1、D1，将C1（28位）、D1（28位）合并得到56位，再经过缩小选择换位2，从而便得到了密钥K0（48位）。依此类推，便可得到K1、K2、…、K15，不过需要注意的是，16次循环左移对应的左移位数要依据下述规则进行：<br>\n循环左移位数<br>\n1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1<br>\n　　以上介绍了DES算法的加密过程。DES算法的解密过程是一样的，区别仅仅在于第一次迭代时用子密钥K15，第二次K14、…，最后一次用K0，算法本身并没有任何变化。</p>\n<p>二、DES算法理论图解</p>\n<p>DES的算法是对称的，既可用于加密又可用于解密。下图是它的算法粗框图。其具体运算过程有如下七步。<br>\n＜缺：找到补上＞</p>\n<p>三、DES算法的应用误区</p>\n<p>DES算法具有极高安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。而56位长的密钥的穷举空间为256，这意味着如果一台计算机的速度是每一秒种检测一百万个密钥，则它搜索完全部密钥就需要将近2285年的时间，可见，这是难以实现的，当然，随着科学技术的发展，当出现超高速计算机后，我们可考虑把DES密钥的长度再增长一些，以此来达到更高的保密程度。<br>\n　　由上述DES算法介绍我们可以看到：DES算法中只用到64位密钥中的其中56位，而第8、16、24、…64位8个位并未参与DES运算，这一点，向我们提出了一个应用上的要求，即DES的安全性是基于除了8，16，24，…64位外的其余56位的组合变化256才得以保证的。因此，在实际应用中，我们应避开使用第8，16，24，…64位作为有效数据位，而使用其它的56位作为有效数据位，才能保证DES算法安全可靠地发挥作用。如果不了解这一点，把密钥Key的8，16，24，… .64位作为有效数据使用，将不能保证DES加密数据的安全性，对运用DES来达到保密作用的系统产生数据被破译的危险，这正是DES算法在应用上的误区，留下了被人攻击、被人破译的极大隐患。</p>\n","_path":"20240322/3-ge-zhu-ming-jia-mi-suan-fa-md5-rsa-des-de-jie-xi/","_link":"https://yaoqs.github.io/20240322/3-ge-zhu-ming-jia-mi-suan-fa-md5-rsa-des-de-jie-xi/","_id":"clzpq9hrb0001sgerd2keaqqj"}}