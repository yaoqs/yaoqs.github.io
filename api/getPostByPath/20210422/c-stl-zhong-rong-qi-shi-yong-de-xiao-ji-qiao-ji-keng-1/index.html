{"type":"getPostByPath","data":{"title":"c++ stl中容器使用的小技巧及坑1","date":"2021-04-22T07:32:28.000Z","description":"","categories":[],"tags":[{"name":"c++","_id":"clzpq9hyy00ahsgeragj8504x"},{"name":"stl","_id":"clzpq9hz200apsgerevy92nvj"}],"content":"<p>以vector为例，在使用auto 关键字重命名容器时容易遇到，使用新命名变量操作容器时，明明已经clear或erase掉了容器，但是再次绑定使用容器时发现容器仍然有数据，未删除数据。示例代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; asdfghjklqwertyuio[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>i&lt;<span class=\"number\">100</span>;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">100</span>;j++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> vec=asdfghjklqwertyuio[i][j];</span><br><span class=\"line\">        vec.<span class=\"built_in\">size</span>();<span class=\"comment\">//这里重新进入大小都会恢复，造成上次clear没有清理/删除的假象</span></span><br><span class=\"line\">        vec.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>(),vec.<span class=\"built_in\">begin</span>()<span class=\"number\">+10</span>;</span><br><span class=\"line\">        vec.<span class=\"built_in\">size</span>();<span class=\"comment\">//这里会变为0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>究其原因是因为 <pre lang=\"c++\">auto vec=asdfghjklqwertyuio[i][j]; </pre>采用了拷贝机制，vec为 <pre lang=\"c++\">asdfghjklqwertyuio[i][j]</pre> 的副本，对vec的操作并未作用到原始容器中，而只是对vec的操作。</p>\n<p>解决方法：</p>\n<ol>\n<li>\n<p>使用左值引用（建议） <pre lang=\"c++\">auto&amp; vec=asdfghjklqwertyuio[i][j];</pre></p>\n</li>\n<li>\n<p>使用骚操作指针 <pre lang=\"c++\">auto vec=&amp;asdfghjklqwertyuio[i][j];</pre> 后期使用容器时使用 <pre lang=\"c++\">(*vec).begin()</pre>等等。<br>\n————————————————<br>\n版权声明：本文为CSDN博主「紫霄宫中布道者」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：<a href=\"https://blog.csdn.net/yaokingson/article/details/116015000\">https://blog.csdn.net/yaokingson/article/details/116015000</a></p>\n</li>\n</ol>\n","_path":"20210422/c-stl-zhong-rong-qi-shi-yong-de-xiao-ji-qiao-ji-keng-1/","_link":"https://yaoqs.github.io/20210422/c-stl-zhong-rong-qi-shi-yong-de-xiao-ji-qiao-ji-keng-1/","_id":"clzpq9hvh0051sger1gnz4jco"}}