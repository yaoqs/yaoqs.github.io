{"type":"getPostById","data":{"title":"【Windows核心编程学习笔记】远程注入ＤＬＬ","date":"2024-03-24T10:49:28.000Z","description":"","categories":[],"tags":[],"content":"<p>转载自 <a href=\"http://blog.chinaunix.net/uid-26275986-id-3141902.html\">【Windows核心编程学习笔记】远程注入ＤＬＬ</a></p>\n<p>远程注入DLL</p>\n<p><strong>一、概述</strong></p>\n<p>为了隐藏自身的进程信息，我们希望将进程作为一个合法进程的线程运行。由于系统进程间不允许直接操作资源，因而我们需要在合法进程内部创建一个线程，为其指定要执行的代码。一种简单的方式是令远程线程载入一个我们编写的DLL，通过DllMain()函数执行我们需要的代码。基本思路是将LoadLibrary()函数作为一个线程函数来调用：</p>\n<p>CreateRemoteThread()----&gt;LoadLibrary()----&gt;DllMain()</p>\n<p>这里的核心函数是CreateRemoteThread()，它用来在远程进程中创建一新线程。我们来看一下这个函数：</p>\n<p>HANDLE WINAPI CreateRemoteThread(</p>\n<p>HANDLE hProcess, //要创建远程线程的进程句柄</p>\n<p>LPSECURITY_ATTRIBUTES lpThreadAttributes, //用于定义新线程的安全属性，这里设为NULL采用默认值即可</p>\n<p>SIZE_T dwStackSize,  //初始化线程堆栈大小，NULL为默认大小</p>\n<p>LPTHREAD_START_ROUTINE lpStartAddress, //线程函数开始的地址</p>\n<p>LPVOID lpParameter,  //线程函数参数</p>\n<p>DWORD dwCreationFlags,  //函数表示创建线程后线程的运行状态</p>\n<p>LPDWORD lpThreadId  //返回线程ID，不关心可以设为NULL不返回</p>\n<p>);</p>\n<p>使用这个函数关键要解决三个参数问题：</p>\n<p>l  获得远程线程的进程句柄，而且要确保相应权限</p>\n<p>l  获取远程进程中线程函数的开始地址，而非本地地址</p>\n<p>l  向远程线程成功传入DLL路径字符串</p>\n<p>解决了这三个问题，我们的远程注入DLL就基本完成了。接下来，这篇笔记的组织结构如下：</p>\n<p>F  获取远程进程句柄</p>\n<p>l  枚举系统进程</p>\n<p>l  提升进程权限</p>\n<p>F  获取LoadLibrary()函数在远程进程中的地址</p>\n<p>F  向远程线程中写入DLL路径字符串</p>\n<p>l  利用VirtualAllocEx()分配远程地址空间</p>\n<p>l  利用WriteProcessMemory()写入远程地址空间</p>\n<p>F  程序源码</p>\n<p>F  运行测试</p>\n<p><strong>二、获取远程进程句柄</strong></p>\n<p>我们主要利用OpenProcess()函数来获得要注入的进程的句柄，句柄是系统中可以起到唯一标识作用的一个对象。我们来看一下OpenProcess()函数：</p>\n<p>HANDLE WINAPI OpenProcess(</p>\n<p>DWORD dwDesiredAccess,  //获取的句柄的访问权限</p>\n<p>BOOL bInheritHandle,    //是否可为新进程继承</p>\n<p>DWORD dwProcessId       //要获取句柄的进程ID</p>\n<p>);</p>\n<p>句柄的访问权限是指我们要使用该进程的句柄做哪些访问操作，对于远程注入DLL来说，主要有：</p>\n<p>PROCESS_CREATE_THREAD |  //For CreateRemoteThread()</p>\n<p>PROCESS_VM_OPERATION |  //For VirtualAllocEx()/VirtualFreeEx()</p>\n<p>PROCESS_VM_WRITE       //For WriteProcessMemory(0</p>\n<p>当然，我们也可以直接设为最高权限：PROCESS_ALL_ACCESS。</p>\n<p>第二个参数说明了是否可为新进程继承，第三个参数需要借助我们编写的子函数ListProcess()来获得。另外需要注意的是，对于很多系统和服务进程而言，获取其带有写权限的句柄需要主调进程拥有调试权限，我们利用子函数EnableDebugPriv()来提升权限。这样在XP下就足够了，在VISTA之后的系统中需要进一步提升另一个隐藏权限，这里只讨论在XP上的情况。</p>\n<p>l  ListProcess()</p>\n<p>我们使用ToolHelpAPI获取当前运行程序的信息，从而编写适合自己需要的工具（@MSDN）。它支持的平台比较广泛，可以在 Windows CE 下使用。在 Windows Mobile SDK 的 Samples 里面有一个 PViewCE 的样例程序，就是用这个来查看进程和线程信息的。</p>\n<p>使用方法就是先用 CreateToolhelp32Snapshot 将当前系统的进程、线程、DLL、堆的信息保存到一个缓冲区，这就是一个系统快照。如果你只是对进程信息感兴趣，那么只要包含 TH32CS_SNAPPROCESS 标志即可。 常见标志如下：</p>\n<p>TH32CS_SNAPHEAPLIST：列举th32ProcessID指定进程中的堆</p>\n<p>TH32CS_SNAPMODULE：列举th32ProcessID指定进程中的模块</p>\n<p>TH32CS_SNAPPROCESS：列举系统范围内的所有进程</p>\n<p>TH32CS_SNAPTHREAD：列举系统范围内的所有线程</p>\n<p>函数执行成功返回快照句柄，否则返回INVALID_HANDLE_VALUE。</p>\n<p>得到系统快照句柄后，我们调用Process32First和Process32Next来依次获取系统中每个进程的信息，将信息存入PROCESSENTRY32结构体中，该结构体中存放着进程的主要信息，如</p>\n<p>DWORD  th32ProcessID;  //进程ID</p>\n<p>DWORD  th32ModuleID;  //进程模块ID</p>\n<p>CHAR   szExeFile[MAX_PATH];  //进程的可执行文件名</p>\n<p>这两个函数当枚举到进程时返回TRUE，否则返回FALSE。<br>\n然后调用一次 Process32First 函数，从快照中获取第一个进程，然后重复调用 Process32Next，直到函数返回 FALSE 为止，这样将遍历快照中进程列表。这两个函数都带两个参数，它们分别是快照句柄和一个 PROCESSENTRY32 结构。调用完 Process32First 或 Process32Next 之后，PROCESSENTRY32 中将包含系统中某个进程的关键信息。其中进程 ID 就存储在此结构的 th32ProcessID。此 ID 传给 OpenProcess API 可以获得该进程的句柄。对应的可执行文件名及其存放路径存放在 szExeFile 结构成员中。在该结构中还可以找到其它一些有用的信息。<br>\n需要注意的是：在调用 Process32First() 之前，要将 PROCESSENTRY32 结构的 dwSize 成员设置成 sizeof(PROCESSENTRY32)。 然后再用 Process32First、Process32Next 来枚举进程。使用结束后要调用 CloseHandle 来释放保存的系统快照。具体程序代码如下：</p>\n<p>//利用ToolHelp32库来枚举当前系统进程</p>\n<p>#include</p>\n<p>#include</p>\n<p>#include</p>\n<p>#include</p>\n<p>int ListProcess()</p>\n<p>{</p>\n<p>//获取系统快照</p>\n<p>HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //不要写错CreateToolhelp32Snapshot()</p>\n<p>if (hProcessSnap == INVALID_HANDLE_VALUE)</p>\n<p>{</p>\n<p>printf(“CreateToolHelp32Snapshot error!\\n”);</p>\n<p>return -1;</p>\n<p>}</p>\n<p>//创建单个进程快照结构体，初始化大小</p>\n<p>PROCESSENTRY32 pe32;</p>\n<p>pe32.dwSize = sizeof(PROCESSENTRY32);  //务必提前初始化，否则默认的大小不一定满足要求</p>\n<p>//初始化缓冲区</p>\n<p>WCHAR buff[1024] = {0}; //PROCESSENTRY32中的szExeFile为WCHAR类型数组，此处应一致，使用Unicode码</p>\n<p>//枚举系统快照链表中的第一个进程项目</p>\n<p>BOOL bProcess = Process32First(hProcessSnap, &amp;pe32);</p>\n<p>while (bProcess)</p>\n<p>{</p>\n<p>//格式化进程名和进程ID，这里要使用printf的宽字符版</p>\n<p>//格式字符串“”都需要用L转换为宽字符形式</p>\n<p>wsprintf(buff, L&quot;FileName:%-30sID:%-6d\\r\\n&quot;, pe32.szExeFile, pe32.th32ProcessID);</p>\n<p>wprintf(L&quot;%s\\n&quot;,buff);</p>\n<p>//缓冲区复位</p>\n<p>memset(buff, 0, sizeof(buff));</p>\n<p>//继续枚举下一个进程</p>\n<p>bProcess = Process32Next(hProcessSnap, &amp;pe32);</p>\n<p>}</p>\n<p>CloseHandle(hProcessSnap);</p>\n<p>return 0;</p>\n<p>}</p>\n<p>l  EnableDebugPriv()</p>\n<p>提升权限主要利用下面四个函数：</p>\n<p>GetCurrentProcessID()        //得到当前进程的ID</p>\n<p>OpenProcessToken()          //得到进程的令牌句柄</p>\n<p>LookupPrivilegeValue()       //查询进程的权限</p>\n<p>AdjustTokenPrivileges()        //调整令牌权限</p>\n<p>进程的权限设置存储在令牌句柄中，我们需要先获取进程的令牌句柄，其次获取进程中权限类型的LUID值，利用此值来设置进程新的权限，具体函数调用顺序如下：</p>\n<p>OpenProcessToken()----&gt;LookupPrivilegeValue()----&gt;AdjustTokenPrivileges()</p>\n<p>具体代码如下：</p>\n<p>#include</p>\n<p>#include</p>\n<p>int EnableDebugPriv(const WCHAR *name)</p>\n<p>{</p>\n<p>HANDLE hToken;   //进程令牌句柄</p>\n<p>TOKEN_PRIVILEGES tp;  //TOKEN_PRIVILEGES结构体，其中包含一个【类型+操作】的权限数组</p>\n<p>LUID luid;       //上述结构体中的类型值</p>\n<p>//打开进程令牌环</p>\n<p>//GetCurrentProcess()获取当前进程的伪句柄，只会指向当前进程或者线程句柄，随时变化</p>\n<p>if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &amp;hToken))</p>\n<p>{</p>\n<p>printf(“OpenProcessToken error\\n”);</p>\n<p>return -8;</p>\n<p>}</p>\n<p>//获得本地进程name所代表的权限类型的局部唯一ID</p>\n<p>if (!LookupPrivilegeValue(NULL, name, &amp;luid))</p>\n<p>{</p>\n<p>printf(“LookupPrivilegeValue error\\n”);</p>\n<p>}</p>\n<p>tp.PrivilegeCount = 1;    //权限数组中只有一个“元素”</p>\n<p>tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;  //权限操作</p>\n<p>tp.Privileges[0].Luid = luid;   //权限类型</p>\n<p>//调整进程权限</p>\n<p>if (!AdjustTokenPrivileges(hToken, 0, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL))</p>\n<p>{</p>\n<p>printf(“AdjustTokenPrivileges error!\\n”);</p>\n<p>return -9;</p>\n<p>}</p>\n<p>return 0;</p>\n<p>}</p>\n<p><strong>三、获取LoadLibrary()的远程地址</strong></p>\n<p>对于Windows系统而言，本地进程和远程进程中的Kernel32.dll被映射到地址空间的同一内存地址，因而只要获取本地进程中LoadLibrary()的地址，在远程进程中也同样是这个地址，可以直接传给CreateRemoteThread()：</p>\n<p>LPTHREAD_START_ROUTINE pLoadLibrary</p>\n<p>=</p>\n<p>(LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(“kernel32.dll”)), “LoadLibraryA”);</p>\n<p>GetProcAddress函数检索指定的动态链接库(DLL)中的输出库函数地址。</p>\n<p>函数原型：</p>\n<p>FARPROC GetProcAddress(</p>\n<p>HMODULE hModule, // DLL模块句柄</p>\n<p>LPCSTR lpProcName // 函数名，以NULL结尾的字符串</p>\n<p>);</p>\n<p>返回值：</p>\n<p>如果函数调用成功，返回值是DLL中的输出函数地址。</p>\n<p>如果函数调用失败，返回值是NULL。得到进一步的错误信息，调用函数GetLastError。</p>\n<p><strong>四、向远程进程中写入DLL路径字符串</strong></p>\n<p>l  VirtualAllocEx()</p>\n<p>如果直接向CreateRemoteThread()传入DLL路径，如”C:\\\\Windows\\\\System32\\\\MyDLL.dll”那么实际向远程线程传递的是一个本地的指针值，这个值在远程进程的地址空间中是没有意义的。所以我们需要使用VirtualAllocEx()函数在远程进程中先分配一段空间，用于直接写入我们的DLL路径。</p>\n<p>函数原形：</p>\n<p>LPVOID VirtualAllocEx(</p>\n<p>HANDLE hProcess,</p>\n<p>LPVOID lpAddress,</p>\n<p>SIZE_T dwSize,</p>\n<p>DWORD flAllocationType,</p>\n<p>DWORD flProtect</p>\n<p>);</p>\n<p>hProcess：</p>\n<p>申请内存所在的进程句柄。</p>\n<p>lpAddress：</p>\n<p>保留页面的内存地址；一般用NULL自动分配 。</p>\n<p>dwSize：</p>\n<p>欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍。</p>\n<p>我们这里的实际代码为：</p>\n<p>//在远程进程中分配内存，准备拷入DLL路径字符串</p>\n<p>//取得当前DLL路径</p>\n<p>char DllPath[260]; //Windows路径最大为</p>\n<p>GetCurrentDirectoryA(260, DllPath);  //获取当前进程执行目录</p>\n<p>printf(“Proces***e Directory is %s\\n”, DllPath);</p>\n<p>strcat(DllPath, “\\\\…\\\\Debug\\\\MyDLL.dll”); //链接到DLL路径</p>\n<p>LPVOID pRemoteDllPath = VirtualAllocEx(hRemoteProcess, NULL, strlen(DllPath) + 1, MEM_COMMIT, PAGE_READWRITE);</p>\n<p>if (pRemoteDllPath == NULL)</p>\n<p>{</p>\n<p>printf(“VirtualAllocEx error\\n”);</p>\n<p>return -3;</p>\n<p>}</p>\n<p>l  WriteProcessMemory()</p>\n<p>我们利用该函数直接向远程进程中分配好的空间中写入DLL路径字符串</p>\n<p>BOOL WriteProcessMemory(</p>\n<p>HANDLE hProcess,      // 进程的句柄，是用OpenProcess打开的</p>\n<p>LPVOID lpBaseAddress, // 要写入的起始地址</p>\n<p>LPVOID lpBuffer,      // 写入的缓存区</p>\n<p>DWORD nSize, // 要写入缓存区的大小</p>\n<p>LPDWORD lpNumberOfBytesWritten          // 这个是返回实际写入的字节。</p>\n<p>);</p>\n<p>我们这里的实际代码为：</p>\n<p>//向远程进程空间中写入DLL路径字符串</p>\n<p>printf(“DllPath is %s\\n”, DllPath);</p>\n<p>DWORD Size;</p>\n<p>if (WriteProcessMemory(hRemoteProcess, pRemoteDllPath, DllPath, strlen(DllPath) +1, &amp;Size) == NULL)</p>\n<p>{</p>\n<p>printf(“WriteProcessMemory error\\n”);</p>\n<p>return -4;</p>\n<p>}</p>\n<p>printf(“WriteRrmoyrProcess Size is %d\\n\\n”, Size);</p>\n<p><strong>五、程序源码</strong></p>\n<p>F  <strong>DLL****源码：</strong></p>\n<p>#include</p>\n<p>#include</p>\n<p>#include</p>\n<p>BOOL APIENTRY DllMain(HINSTANCE hInstDll, DWORD fdwReason, PVOID fImpLoad)</p>\n<p>{</p>\n<p>switch (fdwReason)</p>\n<p>{</p>\n<p>case DLL_PROCESS_ATTACH :</p>\n<p>{</p>\n<p>//The DLL is being mapped into the process’s address space.</p>\n<p>//DWORD ThreadId;</p>\n<p>//CreateThread(NULL, NULL, MessageThread, NULL, NULL, &amp;ThreadId);</p>\n<p>MessageBox(NULL, L&quot;DLL has been mapped!“, L&quot;1st RemoteThread”, MB_OK);</p>\n<p>//打开文件，定义文件指针，指定打开方式为写+追加</p>\n<p>FILE *fp = fopen(“C:\\\\test.txt”, “w”);     //打开方式参数为字符串</p>\n<p>//文件读写函数：</p>\n<p>//读写字符：getc(), putc(); 读写字符串：fgets(), fputs()</p>\n<p>//向标准输入输出读入写出：</p>\n<p>//getchar(), putchar();  gets(0, puts(0;</p>\n<p>fputs(“一个DLL测试文本\\n”, fp);</p>\n<p>//printf(“Test finished\\n”);</p>\n<p>//关闭文件指针，释放内存</p>\n<p>fclose(fp);</p>\n<p>}</p>\n<p>case DLL_THREAD_ATTACH:</p>\n<p>//A Thread is being created.</p>\n<p>MessageBox(NULL, L&quot;RemoteThread has been created!“, L&quot;2nd RemoteThread”, MB_OK);</p>\n<p>break;</p>\n<p>case DLL_THREAD_DETACH:</p>\n<p>//A Thtread is exiting cleanly.</p>\n<p>MessageBox(NULL, L&quot;RemoteThread exit!“, L&quot;13rd RemoteThread”, MB_OK);</p>\n<p>break;</p>\n<p>case DLL_PROCESS_DETACH:</p>\n<p>//The DLL is being ummapped from the process’ address space</p>\n<p>MessageBox(NULL, L&quot;DLL has been unmapped!“, L&quot;4th RemoteThread”, MB_OK);</p>\n<p>break;</p>\n<p>}</p>\n<p>return TRUE;  //Used only for DLL_PROCESS_ATTACH</p>\n<p>}</p>\n<p>F  <strong>RemoteInjectExe.cpp</strong></p>\n<p>#include</p>\n<p>#include</p>\n<p>#include</p>\n<p>#include</p>\n<p>#include</p>\n<p>extern int ListProcess();</p>\n<p>extern int EnableDebugPriv(const WCHAR *);</p>\n<p>int _tmain(int argc, TCHAR *argv[], TCHAR *env[])</p>\n<p>{</p>\n<p>//为了成功使用CreateRemoteThread()函数，必须：</p>\n<p><a href=\"//1.xn--OpenProcess-p18rt357a\">//1.利用OpenProcess</a>()获得远程进程的句柄</p>\n<p><a href=\"//2.xn--VirtualAllocEx-k89wt902b\">//2.利用VirtualAllocEx</a>(),WriteProcessMemory()写入DLL路径字符串</p>\n<p><a href=\"//3.xn--LoadLibrary-z18q742p2n9da7270bxe6bqa\">//3.获得远程进程中LoadLibrary</a>()的确切地址</p>\n<p>//输入进程ID获得进程句柄</p>\n<p>char YesNo;</p>\n<p>printf(“是否查看当前进程列表获得进程ID: Y or N?”);</p>\n<p>scanf(“%c”, &amp;YesNo);</p>\n<p>Sleep(250);</p>\n<p>if (YesNo == ‘Y’ || YesNo == ‘y’)</p>\n<p>ListProcess();</p>\n<p>printf(“请输入要注入的进程ID【‘’表示自身进程】：\\n”);</p>\n<p>DWORD dwRemoteProcessId;</p>\n<p>scanf(“%d”,&amp;dwRemoteProcessId);</p>\n<p>//如果输入“”表示向自身进程注入</p>\n<p>if (dwRemoteProcessId == 0)</p>\n<p>dwRemoteProcessId = GetCurrentProcessId();</p>\n<p>//获得调试权限</p>\n<p>if (EnableDebugPriv(SE_DEBUG_NAME))</p>\n<p>{</p>\n<p>printf(“Add Privilege error\\n”);</p>\n<p>return -1;</p>\n<p>}</p>\n<p>//调用OpenProcess()获得句柄</p>\n<p>HANDLE hRemoteProcess;</p>\n<p>if ((hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwRemoteProcessId)) == NULL)</p>\n<p>{</p>\n<p>printf(“OpenProcess error\\n”);</p>\n<p>printf(“Error Code:%d\\n”,GetLastError());</p>\n<p>system(“pause”);</p>\n<p>return -2;</p>\n<p>}</p>\n<p>//在远程进程中分配内存，准备拷入DLL路径字符串</p>\n<p>//取得当前DLL路径</p>\n<p>char DllPath[260]; //Windows路径最大为</p>\n<p>GetCurrentDirectoryA(260, DllPath);  //获取当前进程执行目录</p>\n<p>printf(“Proces***e Directory is %s\\n”, DllPath);</p>\n<p>strcat(DllPath, “\\\\…\\\\Debug\\\\MyDLL.dll”); //链接到DLL路径</p>\n<p>LPVOID pRemoteDllPath = VirtualAllocEx(hRemoteProcess, NULL, strlen(DllPath) + 1, MEM_COMMIT, PAGE_READWRITE);</p>\n<p>if (pRemoteDllPath == NULL)</p>\n<p>{</p>\n<p>printf(“VirtualAllocEx error\\n”);</p>\n<p>return -3;</p>\n<p>}</p>\n<p>//向远程进程空间中写入DLL路径字符串</p>\n<p>printf(“DllPath is %s\\n”, DllPath);</p>\n<p>DWORD Size;</p>\n<p>if (WriteProcessMemory(hRemoteProcess, pRemoteDllPath, DllPath, strlen(DllPath) +1, &amp;Size) == NULL)</p>\n<p>{</p>\n<p>printf(“WriteProcessMemory error\\n”);</p>\n<p>return -4;</p>\n<p>}</p>\n<p>printf(“WriteRrmoyrProcess Size is %d\\n\\n”, Size);</p>\n<p>//获得远程进程中LoadLibrary()的地址</p>\n<p>LPTHREAD_START_ROUTINE pLoadLibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(“kernel32.dll”)), “LoadLibraryA”);</p>\n<p>if (pLoadLibrary == NULL)</p>\n<p>{</p>\n<p>printf(“GetProcAddress error\\n”);</p>\n<p>return -5;</p>\n<p>}</p>\n<p>else</p>\n<p>{</p>\n<p>printf(“LoadLibrary’s Address is 0x%x\\n\\n”, pLoadLibrary);</p>\n<p>}</p>\n<p>//启动远程线程</p>\n<p>DWORD dwThreadId;</p>\n<p>HANDLE hThread;</p>\n<p>if ((hThread = CreateRemoteThread(hRemoteProcess, NULL, 0, pLoadLibrary, pRemoteDllPath, 0, &amp;dwThreadId)) == NULL)</p>\n<p>{</p>\n<p>printf(“CreateRemoteThread error\\n”);</p>\n<p>return -6;</p>\n<p>}</p>\n<p>else</p>\n<p>{</p>\n<p>WaitForSingleObject(hThread, INFINITE);</p>\n<p>printf(“dwThreadId is %d\\n\\n”, dwThreadId);</p>\n<p>printf(“Inject is done\\n”);</p>\n<p>}</p>\n<p>//释放分配内存</p>\n<p>if (VirtualFreeEx(hRemoteProcess, pRemoteDllPath, 0, MEM_RELEASE) == 0)</p>\n<p>{</p>\n<p>printf(“VitualFreeEx error\\n”);</p>\n<p>return -8;</p>\n<p>}</p>\n<p>//释放句柄</p>\n<p>if (hThread != NULL) CloseHandle(hThread);</p>\n<p>if (hRemoteProcess != NULL) CloseHandle(hRemoteProcess);</p>\n<p>system(“pause”);</p>\n<p>return 0;</p>\n<p>}</p>\n<p><strong>六、运行测试</strong></p>\n<p>１.向记事本进程注入DLL</p>\n<p>这里输出了一些数据作为调试时查看的参考，可以看到写入的DLL路径</p>\n<p>这是DLL加载进远程进程地址空间时的DLL_PROCESS_ATTACH提示</p>\n<p>这是远程线程创建时的DLL_THREAD_ATTACH提示</p>\n<p>这是远程线程退出时DLL_THREAD_DETACH提示</p>\n<p>查看此时记事本进程中的ＤＬＬ模块</p>\n<p>此时没有弹出DLL_PROCESS_DETACH提示，因为我们的DLL还存在于记事本进程中，关闭记事本</p>\n<p>２.向自身进程注入</p>\n<p>在实际编写时，常常会出现各种各样的问题而弄不清原因在本地进程还是远程进程。因而我们设定当输入的进程ＩＤ为０时，向自身进程注入ＤＬＬ</p>\n<p>然而当最后结束的时候却会出现错误：</p>\n<p>在网上查询可以知道这种错误常常是由于杀毒软件或者防火墙造成的，关闭360木马防火墙后运行正常：</p>\n<p>3.向其他进程注入</p>\n<p>l  向Kugoo7.exe注入会弹出360提示，允许后注入成功，之后正常退出，Kugoo7正常运行</p>\n<p>有意思的发现是，由于我们没有卸载Kugou7中的注入的DLL，因而在Kugou7播放的过程中时不时弹出创建线程的消息框提示，可见Kugou7本身在播放音乐的过程中也在不断创建、释放线程。</p>\n<p>l  向搜狗输入法注入，依然是360弹出提示，允许后成功</p>\n<p>仔细观察发现上面360弹出警告的程序点都在源码调用CreateRemoteThread()的时间点，可见360对该API进行了检测。</p>\n<p>l  当向进程查看工具IceSword1.22注入时，在调用OpenProcess()时失败，提示内存分配访问无效，估计是设定了更高的访问权限，使得Ring3级别的访问基本都无效</p>\n","_path":"20240324/windows-he-xin-bian-cheng-xue-xi-bi-ji-yuan-cheng-zhu-ru-dll/","_link":"https://yaoqs.github.io/20240324/windows-he-xin-bian-cheng-xue-xi-bi-ji-yuan-cheng-zhu-ru-dll/","_id":"clzpq9hxe0087sger78ei9o7b"}}