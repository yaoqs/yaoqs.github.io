{"type":"getPostById","data":{"title":"单线程实现同时监听多个端口（windows平台c++代码）","date":"2024-08-08T07:13:43.000Z","description":"","categories":[],"tags":[],"content":"<p>转载自 <a href=\"https://www.cnblogs.com/yuanchenhui/p/icop_accept.html\">单线程实现同时监听多个端口（windows平台c++代码）</a></p>\n<h2 id=\"前言\"><a class=\"header-anchor\" href=\"#前言\">※</a>前言</h2>\n<p>多年前开发了一套网络库，底层实现采用IOCP（完成端口）。该库已在公司多个程序中应用；经过多次修改，长时间检验，已经非常稳定高效。</p>\n<p>最近把以前的代码梳理了一下，又加进了一些新的思路。代码结构更加合理，性能也有所提升。打算将该库一些的知识点写出来，以供参考。</p>\n<p>服务端要在多个端口监听，这种场合并不多见。但作为一个完善的网络库，似乎有必要支持此功能的。</p>\n<h2 id=\"传统实现方法\"><a class=\"header-anchor\" href=\"#传统实现方法\">※</a>传统实现方法</h2>\n<p>如果监听端口个数很少，也可以采用传统的方法。因为accept函数是阻塞的，所以要实现在n个端口监听，就需要n个线程。如果监听端口个数不多，这也不是多大问题。如果监听端口多达几十个，这种方法就有些不妥。线程也是一种资源，线程过多占用资源会增加；也会导致系统负担加重。</p>\n<h2 id=\"更可行的实现方法\"><a class=\"header-anchor\" href=\"#更可行的实现方法\">※</a>更可行的实现方法</h2>\n<p>实现方法有些曲折，需要一步一步分析；基本的原理就是将socket句柄与事件（event）相关联。Windows有相关的函数可以对多个事件监听，当某个事件被触发，就知道相应的socket有事件到达。可以对该socket做accept，因为已经确定该socket有事件了，所以accept函数会立即返回。这样就达到对多个端口同时监听的目的。</p>\n<ol>\n<li>生成socket，并与某个端口绑定</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">LISTEN_SOCKET_INFO</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    UINT16   listenPort;  <span class=\"comment\">//监听端口</span></span><br><span class=\"line\">    SOCKET   listenSocket;<span class=\"comment\">//句柄</span></span><br><span class=\"line\">    WSAEVENT netEvent;    <span class=\"comment\">//socket对应事件</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">IocpAccept::CreateListenInfo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//m_listListenPort存储要监听的端口；总个数不超过64个</span></span><br><span class=\"line\">    std::vector&lt;UINT16&gt;::iterator pos = m_listListenPort.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;pos != m_listListenPort.<span class=\"built_in\">end</span>();++pos)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//生成socket</span></span><br><span class=\"line\">        UINT16 listenPort = *pos;</span><br><span class=\"line\">        LISTEN_SOCKET_INFO socketInfo;</span><br><span class=\"line\">        socketInfo.listenSocket = <span class=\"built_in\">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class=\"line\">        socketInfo.listenPort = listenPort;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//绑定端口</span></span><br><span class=\"line\">        sockaddr_in InetAddr;</span><br><span class=\"line\">        InetAddr.sin_family = AF_INET;</span><br><span class=\"line\">        InetAddr.sin_addr.s_addr = <span class=\"built_in\">htonl</span>(INADDR_ANY);</span><br><span class=\"line\">        InetAddr.sin_port = <span class=\"built_in\">htons</span>(listenPort);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">bind</span>(socketInfo.listenSocket, (SOCKADDR *)&amp;InetAddr, <span class=\"built_in\">sizeof</span>(InetAddr));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SOCKET_ERROR == ret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">closesocket</span>(socketInfo.listenSocket);</span><br><span class=\"line\">            <span class=\"comment\">//绑定失败</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//生成事件</span></span><br><span class=\"line\">        socketInfo.netEvent = <span class=\"built_in\">WSACreateEvent</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//将socket句柄与事件关联起来。只监视socket的accept和close消息</span></span><br><span class=\"line\">        ret = <span class=\"built_in\">WSAEventSelect</span>(socketInfo.listenSocket, socketInfo.netEvent, FD_ACCEPT | FD_CLOSE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SOCKET_ERROR == ret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">closesocket</span>(socketInfo.listenSocket);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动监听</span></span><br><span class=\"line\">        ret = <span class=\"built_in\">listen</span>(socketInfo.listenSocket, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SOCKET_ERROR == ret)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ::<span class=\"built_in\">closesocket</span>(socketInfo.listenSocket);</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        m_listListenInfo.<span class=\"built_in\">push_back</span>(socketInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数已将需要的数据存储在列表m_listListenInfo中。</p>\n<ol start=\"2\">\n<li>启动监听线程，对多个事件监听</li>\n</ol>\n<p>对多个事件监听用到如下函数：</p>\n<p><code>DWORD WSAAPI WSAWaitForMultipleEvents( DWORD cEvents, const WSAEVENT *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable );</code>该函数最多可以对64个事件做跟踪，所以一个线程最多可以对64个端口做监听。（同时对超过64个端口监听的场合非常少见。本文不考虑。）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生成事件地址指针</span></span><br><span class=\"line\"><span class=\"type\">int</span> nEventTotal;</span><br><span class=\"line\">WSAEVENT* pEventArray = <span class=\"built_in\">CreateNetEventArray</span>(&amp;nEventTotal);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nEventTotal == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">assert</span>(nEventTotal &lt;= WSA_MAXIMUM_WAIT_EVENTS);</span><br><span class=\"line\">MSG msg;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (m_bServerStart)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 同时对多个事件做监听</span></span><br><span class=\"line\">    DWORD index = <span class=\"built_in\">WSAWaitForMultipleEvents</span>(nEventTotal,</span><br><span class=\"line\">        pEventArray,</span><br><span class=\"line\">        FALSE,</span><br><span class=\"line\">        <span class=\"number\">10000</span>,</span><br><span class=\"line\">        FALSE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_bServerStart)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//查看是哪个事件触发函数返回</span></span><br><span class=\"line\">    index = index - WSA_WAIT_EVENT_0;</span><br><span class=\"line\">    <span class=\"comment\">//客户端连接事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((index != WSA_WAIT_FAILED) &amp;&amp; (index != WSA_WAIT_TIMEOUT))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//pEventArray排序与m_listListenInfo一样，所以可以根据index找到对应的socket。</span></span><br><span class=\"line\">        <span class=\"comment\">//就是该socket导致函数返回</span></span><br><span class=\"line\">        LISTEN_SOCKET_INFO socketInfo = m_listListenInfo[index];</span><br><span class=\"line\">        <span class=\"comment\">//查看具体是什么事件导致函数返回</span></span><br><span class=\"line\">        WSANETWORKEVENTS NetworkEvents;</span><br><span class=\"line\">        <span class=\"built_in\">WSAEnumNetworkEvents</span>(socketInfo.listenSocket, pEventArray[index], &amp;NetworkEvents);</span><br><span class=\"line\">        <span class=\"comment\">//如果是accept事件，说明有客户端连接此端口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (NetworkEvents.lNetworkEvents == FD_ACCEPT</span><br><span class=\"line\">            &amp;&amp; NetworkEvents.iErrorCode[FD_ACCEPT_BIT] == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这时调用accept函数，会立即返回</span></span><br><span class=\"line\">            <span class=\"built_in\">AcceptListenPort</span>(socketInfo.listenSocket, socketInfo.listenPort);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (NetworkEvents.lNetworkEvents == FD_CLOSE</span><br><span class=\"line\">            &amp;&amp; NetworkEvents.iErrorCode[FD_CLOSE_BIT] == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">assert</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//因为超时等其他原因引起函数返回</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下文accept函数调用，并不会阻塞。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">UINT <span class=\"title\">IocpAccept::AcceptListenPort</span><span class=\"params\">(SOCKET hListenSocket, UINT16 nListenPort)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SOCKET hClient = <span class=\"number\">0</span>;</span><br><span class=\"line\">    SOCKADDR_IN localAddr;</span><br><span class=\"line\">    <span class=\"type\">int</span> iaddrSize = <span class=\"built_in\">sizeof</span>(SOCKADDR_IN);</span><br><span class=\"line\"></span><br><span class=\"line\">    hClient = <span class=\"built_in\">accept</span>(hListenSocket, (<span class=\"keyword\">struct</span> sockaddr *)&amp;localAddr, &amp;iaddrSize);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INVALID_SOCKET == hClient)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nAccepetError = <span class=\"built_in\">WSAGetLastError</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nAccepetError == WSAECONNRESET)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取了一个客户端连接</span></span><br><span class=\"line\">        <span class=\"built_in\">OnAcceptClient</span>(hClient, nListenPort);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\"><a class=\"header-anchor\" href=\"#后记\">※</a>后记</h2>\n<p>同时对多个端口做监听，可能还有更好的方法。如果对几百个以上端口做监听，此方法可能就不太合适。通常情况下，对多个端口监听的场景比较少见，所以对更优化的处理方法也没深究。</p>\n<p>代码下载地址： <a href=\"https://download.csdn.net/download/qq_29939347/10691921\">https://download.csdn.net/download/qq_29939347/10691921</a></p>\n","_path":"20240808/dan-xian-cheng-shi-xian-tong-shi-jian-ting-duo-ge-duan-kou-windows-ping-tai-c-dai-ma/","_link":"https://yaoqs.github.io/20240808/dan-xian-cheng-shi-xian-tong-shi-jian-ting-duo-ge-duan-kou-windows-ping-tai-c-dai-ma/","_id":"clzpq9hx5007usger1pvl5w70"}}